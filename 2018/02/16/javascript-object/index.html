<!DOCTYPE html><html lang="korean"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Javascript | 객체 | Dev diary</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://yoursite.com/2018/02/16/javascript-object/"/>
<meta name="description" content="자바스크립트의 기본 데이터 타입은 객체다.객체는 일종의 복합체로, 여러 값(원시 타입의 값 또는 다른 객체)들을 묶어 이름으로 저장하고,값을 가져올 수 있다.즉, 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다. 프로퍼티의 이름은…">
<meta name="keywords" content="Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript | 객체">
<meta property="og:url" content="http://yoursite.com/2018/02/16/javascript-object/">
<meta property="og:site_name" content="Dev diary">
<meta property="og:description" content="자바스크립트의 기본 데이터 타입은 객체다.객체는 일종의 복합체로, 여러 값(원시 타입의 값 또는 다른 객체)들을 묶어 이름으로 저장하고,값을 가져올 수 있다.즉, 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다. 프로퍼티의 이름은…">
<meta property="og:locale" content="korean">
<meta property="og:image" content="http://yoursite.com/images/javascript.png">
<meta property="og:updated_time" content="2018-02-16T03:56:15.365Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript | 객체">
<meta name="twitter:description" content="자바스크립트의 기본 데이터 타입은 객체다.객체는 일종의 복합체로, 여러 값(원시 타입의 값 또는 다른 객체)들을 묶어 이름으로 저장하고,값을 가져올 수 있다.즉, 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다. 프로퍼티의 이름은…">
<meta name="twitter:image" content="http://yoursite.com/images/javascript.png"><meta property="article:author" content="circleGiven"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-02-16 10:07:20"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="circleGiven"><link rel="icon" href="/images/favicon.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="Dev diary"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/favicon.png" alt="Dev diary"><span class="menu__item__link--brand__label">Dev diary</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">Javascript | 객체</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-02-16T01:07:20.000Z" itemprop="datePublished">2018-02-16 10:07:20</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/Dev/">Dev</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/Dev/Javascript/">Javascript</a></div></div><div class="article__contents"><img src="/images/javascript.png"/><p>자바스크립트의 기본 데이터 타입은 <strong>객체</strong>다.<br>객체는 일종의 <strong>복합체</strong>로, 여러 값(원시 타입의 값 또는 다른 객체)들을 묶어 이름으로 저장하고,<br>값을 가져올 수 있다.<br>즉, <strong>객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합</strong>이다.</p>
<p>프로퍼티의 이름은 문자열이기 때문에, 객체는 문자열을 값에 대응시키는 구조라고 할 수 있다.<br>이런 대응관계는 많은 자료구조들이 제공하는, 친근한 개념이다.<br>(해시, 해시 테이블, 사전, 연관배열 등)</p>
<p>하지만 객체는 단순히 문자열과 값의 대응관계인 것은 아니다.<br>자바스크립트 객체는 객체가 가진 고유 프로퍼티를 유지하는 것 외에 <strong>‘프로토타입’</strong>이라고 하는 다른 객체의 프로퍼티를 <strong>상속</strong>받는다.<br>객체의 메서드들은 일반적으로 상속받은 프로퍼티이고, 이를 <strong>‘프로토타입 상속’</strong>이라고 한다.<br>(프로토타입 상속은 자바스크립트의 핵심적 특징이다)</p>
<p>자바스크립트 객체는 프로퍼티를 동적으로 추가하고 제거할 수 있기 때문에 동적이다.<br>하지만 자바스크립트의 객체는 정적 객체를 흉내 낼 수도 있고,<br>정적 타입 언어에서의 ‘구조체’처럼 사용할 수도 있다.<br>또한 문자열-값 매핑에서 값을 무시하면 문자열 집합을 표현하는 데도 사용할 수 있다.</p>
<p>자바스크립트에서는 문자열(string)과 숫자(number), true/false, null/undefined를 제외한 나머지는 객체다.<br>위 값들은 객체는 아니지만 변경 불가능 객체처럼 동작한다.</p>
<p>객체는 변경이 가능하며ㅏ, 그 값 대신에 <strong>참조(reference)</strong>를 통해 조작한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> y = x;</span><br><span class="line"></span><br><span class="line">y[<span class="string">'a'</span>] = <span class="number">1</span>; <span class="comment">//변수 y를 통한 객체 수정</span></span><br><span class="line"></span><br><span class="line">x; <span class="comment">//&#123;a : 1&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>변수 x가 object를 가르키고 변수 y에 x를 할당한다면,<br>객체 자체를 복사하지 않고 객체를 <strong>참조</strong>한다.<br>그렇기 때문에, 변수 y를 통한 객체의 수정은 변수 x를 통해서도 확인이 가능하다.</p>
<p>객체로 가장 많이하는 작업은<br>객체를 생성한 후, 프로퍼티를 추가, 질의, 삭제, 테스트, 열거하는 것이다.<br>앞으로 이러한 기본적인 연산들에 대해 다룰 것이다.</p>
<p>프로퍼티는 이름과 값으로 구성된다.<br><strong>프로퍼티 이름</strong>은 빈 문자열을 포함한 어떤 문자열이든 될 수 있다.<br>하지만, 객체가 같은 이름의 프로퍼티를 두 개 가질 수는 없다.<br><strong>프로퍼티 값</strong>은 자바스크립트의 어떠한 값이든 될 수 있고,<br>ECMAScript5에서는 getter와 setter 함수도 될 수 있다.</p>
<p>프로퍼티의 이름과 값 이외에,<br>객체의 각 프로퍼티는 <strong>‘프로퍼티 속성(property attribute)’</strong>이라고 하는 연관된 값을 갖는다.</p>
<ul>
<li><strong>쓰기(writable)</strong> 속성은 프로퍼티 값의 수정 가능 여부를 결정한다.</li>
<li><strong>열거(enumerable)</strong> 속성은 프로퍼티의 이름을 <code>for/in</code> 루프에서 읽을 수 있는지 여부를 결정한다.</li>
<li><strong>설정(configurable)</strong> 속성은 프로퍼티의 삭제 가능여부와 프로퍼티 속성의 변경 가능여부를 결정한다.</li>
</ul>
<p>ECMAScript5 이전에는 코드에서 생성한 객체의 프로퍼티는 전부 수정, 열거, 설정할 수 있었다.<br>하지만, 이후 부터는 사용자가 만든 프로퍼티의 속성만을 변경할 수 있다.</p>
<p>프로퍼티 뿐만 아니라,<br>모든 객체는 세 가지의 <strong>속성(object attribute)</strong>을 갖는다.</p>
<ul>
<li><strong>prototype</strong>은 상속받은 프로퍼티들을 가진 객체를 참조한다.</li>
<li><strong>class</strong>는 객체의 자료형(타입)을 특정짓는 문자열이다.</li>
<li><strong>extensible</strong>속성은 객체에 새 프로퍼티를 추가할 수 있는지를 결정한다.(ECMAScript5)</li>
</ul>
<p><br><br>세 종류의 자바스크립트 객체</p>
<ul>
<li><strong>네이티브 객체(native object)</strong>는 ECMAScript 명세에 정의된 객체 또는 그 객체의 클래스다.<br><code>Array</code>, <code>Function</code>, <code>Date</code>, <code>정규표현식</code>들은 전부 네이티브 객체이다.</li>
<li><strong>호스트 객체(host object)</strong>는 브라우저와 같이 자바스크립트 인터프리터가 내장된 호스트 환경에 정의된 객체다.<br><code>HTMLElement</code> 객체는 웹 페이지의 구조가 클라이언트 측 자바스크립트로 표현된 호스트 객체다.<br>호스트 환경에서 메서드들을 정의할 때 일반적으로 자바스크립트 <code>Function</code> 객체로 정의하는 것과 마찬가지로,<br>호스트 객체는 네이티브 객체일 수도 있다.</li>
<li><strong>사용자 정의 객체(user-defined object)</strong>는 자바스크립트 코드의 실행으로 생성된 객체다.</li>
</ul>
<p>두 종류의 프로퍼티</p>
<ul>
<li><strong>고유 프로퍼티(own property)</strong>는 객체에 직접 정의된 프로퍼티다.</li>
<li><strong>상속받은 프로퍼티(inherited property)</strong>는 객체의 프로토타입 객체가 정의한 프로퍼티를 말한다.</li>
</ul>
<p><br><br><br></p>
<h1 id="객체-생성하기"><a href="#객체-생성하기" class="headerlink" title="객체 생성하기"></a>객체 생성하기</h1><p><strong>객체 리터럴</strong>을 통해 만들 수도 있고, <code>new</code>키워드를 사용해 만들 수도 있으며,<br>ECMAScript5의 <strong>Object.create()</strong> 함수를 통해 생성할 수도 있다.<br><br></p>
<h2 id="객체-리터럴"><a href="#객체-리터럴" class="headerlink" title="- 객체 리터럴"></a>- 객체 리터럴</h2><p>객체를 생성하는 가장 쉬운 방법이다.<br>객체 리터럴은 중괄호(<code>{}</code>)안에, 이름과 값을 콜론(<code>:</code>)으로 구분한 순서 쌍을 쉼표(<code>,</code>)로 연결한 리스트다.<br>프로퍼티 이름으로는 자바스크립트 식별자 또는 문자열을 사용할 수 있다.<br>프로퍼티 값으로는 자바스크립트 표현식을 사용할 수 있다.<br>(표현식의 값(원시 값 또는 객체 값)은 곧 프로퍼티의 값이 된다)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = &#123;&#125;;                           <span class="comment">//빈 객체</span></span><br><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span> &#125;;                 <span class="comment">//두 개의 프로퍼티</span></span><br><span class="line"><span class="keyword">var</span> point2 = &#123; <span class="attr">x</span>:point.x, <span class="attr">y</span>:point.y &#125;;    <span class="comment">//프로퍼티를 수식의 값으로 정의</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="string">"main title"</span>: <span class="string">"JavaScript"</span>,           <span class="comment">//프로퍼티 이름은 공백과</span></span><br><span class="line">    <span class="string">'sub-title'</span>: <span class="string">"The Definitive Guide"</span>,  <span class="comment">//하이픈을 포함할 수 있다</span></span><br><span class="line">    <span class="string">"for"</span>: <span class="string">"all audiences"</span>,               <span class="comment">//예약어는 인용부호로 둘러싸서 문자열 리터럴로 사용</span></span><br><span class="line">    author: &#123;                             <span class="comment">//프로퍼티 author의 값은 객체이다</span></span><br><span class="line">        firstname: <span class="string">"David"</span>,               <span class="comment">//프로퍼티 이름은 인용부호로 감싸지 않을 수도 있다</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>ECMAScript5와 ECMAScript3 일부 구현에서는 <strong>예약어</strong>를 <strong>인용부호(<code>&quot; &#39;</code>)</strong>로 감싸지 않고도 프로퍼티를 이름으로 사용할 수 있다.<br>하지만 일반적으로 ECMAScript3 에서 프로퍼티 이름으로 예약어를 사용하려면 반드시 인용부호로 감싸야 한다.</p>
<p>ECMAScript5에서 객체 리터럴의 마지막 프로퍼티 값 뒤에 오는 쉼표는 무시된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123;</span><br><span class="line">    x:<span class="number">0</span>,</span><br><span class="line">    y:<span class="number">0</span>,        <span class="comment">//이 쉼표는 무시된다</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>대부분 ECMAScript3 구현체가 마지막 프로퍼티 값 뒤에 오는 쉼표는 무시하지만 IE는 이를 Error로 간주한다.</p>
<p><strong>객체 리터럴은 평가될 때마다 새로운 객체를 생성하고 초기화하는 표현식</strong>이다.<br>각 프로퍼티의 값 또한 리터럴이 평가될 때마다 새롭게 계산된다.<br>즉, 하나의 객체 리터럴은 수많은 객체를 만들 수 있다.<br>객체 리터럴이 반복적으로 호출되는 함수 내부의 루프 몸체에 있는경우,<br>매 순간 생기는 객체의 프로퍼티 값들은 서로 다를것이다.<br><br></p>
<h2 id="new"><a href="#new" class="headerlink" title="- new"></a>- new</h2><p><code>new</code>연산자는 객체를 만들고 초기화한다.<br><code>new</code>키워드 다음에는 반드시 함수 호출문이 와야한다.<br>이때 호출되는 함수를 <strong>생성자(constructor)</strong>라고 하는데, <strong>새로 생성된 객체를 초기화</strong>하는 역할을 한다.<br>코어 자바스크립트는 기본 타입에 대한 생성자를 내장하고 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"js"</span>);</span><br></pre></td></tr></table></figure></p>
<p>기본 타입에 대한 생성자 뿐만 아니라,<br>원하는 형태의 객체를 생성하고 초기화하기 위해 임의의 생성자 함수를 직접 정의할 수도 있다.<br><br></p>
<h2 id="프로토타입"><a href="#프로토타입" class="headerlink" title="- 프로토타입"></a>- 프로토타입</h2><p><strong>Object.create()</strong>를 보기전에 먼저 프로토타입에 대해 알아야만 한다.<br>자바스크립트의 모든 객체(A)는 또 다른 자바스크립트 객체(극히 드물지만 null일 수도 있음)와 연관되어 있다.<br>이 연관된 객체를 <strong>프로토타입(prototype)</strong>이라고 한다.<br>객체(A)는 프로토타입으로부터 프로퍼티들을 <strong>상속</strong>받는다.</p>
<p>객체 리터럴로 생성된 모든 객체는 프로토타입 객체가 같으며,<br>이 프로토타입 객체는 <strong>Object.prototype</strong>으로 참조할 수 있다.</p>
<p><code>new</code>키워드를 사용해 생성자를 호출하면, 생성자 함수의 프로토타입이 생성된 객체의 프로토타입이 된다.<br>따라서 <strong>new Object()</strong>로 생성된 객체는 <strong>{}</strong>로 생성된 객체와 마찬가지로  <strong>Object.prototype</strong>를 상속받는다.<br>마찬가지로, <strong>new Array()</strong>로 생성된 객체는 <strong>Array.prototype*을 객체의 프로토타입으로 사용하고,
</strong>new Date()<strong>로 생성된 객체는 </strong>Date.prototype**을 객체의 프로토타입으로 사용한다.</p>
<p><strong>Object.prototype</strong>은 프로토타입이 없는 매우 드문 객체 중 하나다.<br>즉, 아무런 프로퍼티도 상속받지 않는다.<br><strong>Object</strong>는 <strong>최상위</strong>이기 때문이다.</p>
<p><strong>Object</strong>가 <strong>최상위</strong> 이기 때문에,<br>다른 프로토타입 객체들은 보통 프로토타입을 갖는다.<br>모든 내장 생성자는 <strong>Object.prototype</strong>을 상속하는 객체를 프로토타입으로 갖는다.</p>
<p><strong>Date.prototype</strong>은 <strong>Object.prototype</strong>의 프로퍼티들을 상속받는다.<br>따라서 <strong>Date()</strong>로 생성된 Date객체는 <strong>Object.prototype</strong>를 상속받은 <strong>Date.prototype</strong>의 프로퍼티들을 상속받게 된다.</p>
<blockquote>
<p>Object.prototype - Date.prototype - new Date()</p>
</blockquote>
<p>이처럼 프로토타입 객체들이 연결된 것을 <strong>‘프로토타입 체인’</strong>이라고 한다.<br><br></p>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="- Object.create()"></a>- Object.create()</h2><p>ECMAScript5는 객체를 생성하는 <strong>Object.create()</strong> 메서드를 지원한다.<br>이 메서드의 첫 번째 인자가 프로토타입 객체다.<br><strong>Object.create()</strong>는 새 객체의 프로퍼티 정보를 두 번째 인자로 받을 수 있는데, 두 번째 인자는 생략이 가능하다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(프로토타입 객체, [프로퍼티 설정]);</span><br></pre></td></tr></table></figure></p>
<p><strong>Object.create()</strong>는 정적 함수로 개별 객체를 통해 호출되는 메서드가 아니다.<br>함수를 사용하기 위해서는 단순히 프로토타입 객체를 넘기기만 하면 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;); <span class="comment">//o는 x,y 프로퍼티를 상속받는다</span></span><br></pre></td></tr></table></figure></p>
<p>이 <strong>Object.create()</strong>를 사용하는 것은 <strong>{}</strong>나 <strong>new Object()</strong>로 생성하는 것과 완전히 다르다.<br>해당 객체를 상속받아 생성하기 때문에 두 방법과는 달리 한번 더 프로토타입이 감싸져 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(&#123;<span class="attr">X</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// &#123;&#125;</span></span><br><span class="line">   <span class="comment">//  __proto__:</span></span><br><span class="line">   <span class="comment">//     x: 1</span></span><br><span class="line">   <span class="comment">//     __proto__: Object</span></span><br><span class="line"></span><br><span class="line">b; <span class="comment">// &#123;x:1&#125;</span></span><br><span class="line">   <span class="comment">//  __proto__: Object</span></span><br></pre></td></tr></table></figure></p>
<p>a의 경우 다음과 같은 구조이다.</p>
<blockquote>
<p>Object.prototype - {x:1} - a</p>
</blockquote>
<p>b의 경우 다음과 같은 구조이다.</p>
<blockquote>
<p>Object.prototype - b</p>
</blockquote>
<p>프로토타입을 갖지 않는 새 객체를 만들기 위해서는 함수에 null을 전달하면 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>그러나 이렇게 생성된 객체는 어떠한 객체도 상속받지 않기 때문에 toString() 같은 기본적인 메서드조차 사용할 수 없다.<br>즉, <code>+</code> 연산자도 사용할 수 없다.<br>만약 <strong>{}</strong> 또는 <strong>new Object()</strong>가 만들어내는 것과 같은 일반적인 빈 객체를 반들고 싶으면 <strong>Object.prototype</strong>을 전달하면 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var o = &#123;&#125;; var o = new Object(); 와 완전히 동일</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure></p>
<p>임의의 프로토타입으로 새 객체를 만들 수 있다는 점(특정 객체를 상속받는 <strong>‘상속자’</strong>객체를 만들 수 있다는 점)에서 매우 유용하다,<br>ECMAScript3에서는 다음과 같이 구현할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토타입 객체 o의 속성을 상속받아 새로운 객체를 생성하여 반환</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>(); <span class="comment">//o는 null이 아닌 객체여야 한다</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Object.create()를 사용 가능한 경우</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create) &#123;              <span class="comment">//Object.create()를 사용할 수 있다면</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(o);      <span class="comment">//Object.create()를 사용하고 객체를 생성하여 반환</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Object.create()를 사용하지 못하는 경우</span></span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> o;                 <span class="comment">//만약 객체의 타입검사가 필요한 경우</span></span><br><span class="line">    <span class="keyword">if</span> (t !== <span class="string">"object"</span> &amp;&amp; t !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;                  <span class="comment">//임시로 빈 생성자 함수를 정의</span></span><br><span class="line">    f.prototype = o;                  <span class="comment">//f의 프로토타입 프로퍼티를 o로 설정</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f();                   <span class="comment">//함수 f()를 사용</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위 <strong>inherit()</strong> 함수는 <strong>Object.create()</strong>를 대체할 만큼 완벽하지 않다.<br><strong>inherit()</strong> 함수는 객체 생성 시 빈 프로토타입 객체를 통해 만들 수 없고,<br><strong>Object.create()</strong>의 두 번째 인자(생성할 객체의 프로퍼티 설정)과 같은 선택 인자를 받지 않는다.</p>
<p><strong>inherit()</strong> 함수를 사용하면, 객체가 임의의 라이브러리 함수에 의해 뜻하지 않게 수정되는 것을 막을 수 있다.<br>함수에 객체를 직접 전달하는 대신 해당 객체의 프로퍼티를 상속한 객체를 전달하는 것이다.<br>따라서 함수가 프로퍼티를 읽는다면, 상속받은 값을 보게된다.<br>만약 함수가 프로퍼티를 설정한다면, 이는 기존의 객체가 아닌 새로 만들어진 객체에만 영향을 미친다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = inherit(a);</span><br><span class="line">b[<span class="string">"y"</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">//&#123;x:1&#125;</span></span><br><span class="line">b; <span class="comment">//&#123;x:1, y:2&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="프로퍼티-접근-및-설정"><a href="#프로퍼티-접근-및-설정" class="headerlink" title="프로퍼티 접근 및 설정"></a>프로퍼티 접근 및 설정</h1><p>프로퍼티의 값을 가져오기 위해서는 마침표(<code>.</code>) 연산자 또는 대괄호(<code>[]</code>) 연산자를 사용한다.<br>연산자 좌측에는 객체로 평가되는 표현식이 와야 한다.<br>마침표(<code>.</code>) 연산자를 사용할 경우에는 연산자 우측에 반드시 프로퍼티 이름이 식별자로 와야한다.<br>대괄호(<code>[]</code>) 연산자를 사용할 경우, 대괄호(<code>[]</code>)안의 값은 반드시 프로퍼티 이름의 문자열로 평가되는 표현식이어야 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> author = book.author;       <span class="comment">//book객체에서 author 프로퍼티를 가져옴</span></span><br><span class="line"><span class="keyword">var</span> name = author.surname;      <span class="comment">//author객체에서 surname 프로퍼티를 가져옴</span></span><br><span class="line"><span class="keyword">var</span> title = book[<span class="string">"main title"</span>]; <span class="comment">//book객체에서 main title 프로퍼티를 가져옴</span></span><br></pre></td></tr></table></figure></p>
<p>프로퍼티를 만들거나 설정하기 위해서는 객체의 프로퍼티에 접근할 때와 동일하게 마침표(<code>.</code>) 또는 대괄호(<code>[]</code>) 연산자를 사용한다.<br>이때 프로퍼티는 할당 표현식의 왼쪽에 위치한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book.edition = <span class="number">6</span>;                   <span class="comment">//edition 프로퍼티를 만든다</span></span><br><span class="line">book[<span class="string">"main title"</span>] = <span class="string">"ECMAScript"</span>;  <span class="comment">//main title 프로퍼티를 만든다</span></span><br></pre></td></tr></table></figure></p>
<p>ECMAScript3 에서는 마침표(<code>.</code>) 연산자 다음에 오는 식별자로 예약어를 사용할 수 없다.<br>즉, <strong>o.for</strong> 나 <strong>o.class</strong> 처럼 할 수 없다.<br><code>for</code>는 언어에서 사용하는 키워드고, <code>class</code>는 추후에 사용하라고 예약된 단어다.<br>만약 객체에 프로퍼티 이름으로 예약어를 사용하려면 <strong>o[‘for’]</strong>나 <strong>o[‘class’]</strong>처럼 반드시 <code>[]</code>연산자를 사용해야 한다.<br>일부 ECMAScript3 구현체와 ECMAScript5는 이러한 제한을 완화해 마침표(<code>.</code>) 연산자 다음에 예약어를 사용할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//일부 ECMAScript3 구현체와 ECMAScript5</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.for = <span class="number">1</span>;  <span class="comment">//OK!</span></span><br><span class="line"></span><br><span class="line">o;          <span class="comment">//&#123;for:1&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><code>[]</code>연산자를 사용할 경우, 연산자 안에 문자열로 평가되는 표현식이 들어가야 한다.<br>정확히 말해, 문자열 표현식 또는 값이 <strong>문자열로 변환될 수 있는 표현식</strong>이어야 한다는 말이다.<br>그래서 숫자가 가능한 것이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o[<span class="number">1</span>] = <span class="number">22</span>;  <span class="comment">//OK!</span></span><br><span class="line"></span><br><span class="line">o;          <span class="comment">//&#123;1:22&#125;</span></span><br></pre></td></tr></table></figure></p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/Javascript/">Javascript</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.jpeg" alt="circleGiven"><a class="article__author__link" title="About circleGiven" rel="author">circleGiven</a><p class="article__author__desc">아직 배울게 너무 많은 '초보 개발자'</p><div class="article__author__socials"><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="circleGiven"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//circleGiven.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-02-16T03:56:15.365Z"><meta itemprop="articleBody" content="자바스크립트의 기본 데이터 타입은 객체다.객체는 일종의 복합체로, 여러 값(원시 타입의 값 또는 다른 객체)들을 묶어 이름으로 저장하고,값을 가져올 수 있다.즉, 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다.
프로퍼티의 이름은 문자열이기 때문에, 객체는 문자열을 값에 대응시키는 구조라고 할 수 있다.이런 대응관계는 많은..."><meta itemprop="url" content="http://yoursite.com/2018/02/16/javascript-object/"><meta itemprop="mainEntityOfPage" content="http://yoursite.com/2018/02/16/javascript-object/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="Dev diary"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://yoursite.com/images/favicon.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://yoursite.com/images/javascript.png"><meta itemprop="url" content="http://yoursite.com/images/javascript.png"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/02/03/javascript-expression-operator/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 표현식과 연산자</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/08/javascript-type/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 타입, 값, 변수</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/02/10/javascript-statement/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 문장</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2018/02/16/javascript-object/">Javascript | 객체</a></li><li class="recent-posts__item"><a href="/2018/02/10/javascript-statement/">Javascript | 문장</a></li><li class="recent-posts__item"><a href="/2018/02/03/javascript-expression-operator/">Javascript | 표현식과 연산자</a></li><li class="recent-posts__item"><a href="/2018/01/21/typescript-interface/">Typescript | Interface</a></li><li class="recent-posts__item"><a href="/2018/01/19/class-abstract-interface/">class 와 abstract 그리고 interface 이야기</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">9</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/Speech/">Speech</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/">Dev</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/Javascript/">Javascript</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/Typescript/">Typescript</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/SICP/">SICP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Story/">Story</a><span class="category-list-count">1</span></li></ul></li></ul></div></div></div><p class="copyright"><small>© 2018 circleGiven<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>