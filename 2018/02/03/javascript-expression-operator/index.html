<!DOCTYPE html><html lang="korean"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Javascript | 표현식과 연산자 | Dev diary</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://yoursite.com/2018/02/03/javascript-expression-operator/"/>
<meta name="description" content="표현식(expression)은 자바스크립트 인터프리터가 값으로 평가하는 자바스크립트 구문이다.변수 이름 또한 간단한 표현식으로, 변수에 할당된 임의의 값으로 평가된다.이 표현식들을 이용해 복잡한 표현식을 만들 수 있다. 바로…">
<meta name="keywords" content="Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript | 표현식과 연산자">
<meta property="og:url" content="http://yoursite.com/2018/02/03/javascript-expression-operator/">
<meta property="og:site_name" content="Dev diary">
<meta property="og:description" content="표현식(expression)은 자바스크립트 인터프리터가 값으로 평가하는 자바스크립트 구문이다.변수 이름 또한 간단한 표현식으로, 변수에 할당된 임의의 값으로 평가된다.이 표현식들을 이용해 복잡한 표현식을 만들 수 있다. 바로…">
<meta property="og:locale" content="korean">
<meta property="og:image" content="http://yoursite.com/images/javascript.png">
<meta property="og:updated_time" content="2018-02-06T08:31:41.271Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript | 표현식과 연산자">
<meta name="twitter:description" content="표현식(expression)은 자바스크립트 인터프리터가 값으로 평가하는 자바스크립트 구문이다.변수 이름 또한 간단한 표현식으로, 변수에 할당된 임의의 값으로 평가된다.이 표현식들을 이용해 복잡한 표현식을 만들 수 있다. 바로…">
<meta name="twitter:image" content="http://yoursite.com/images/javascript.png"><meta property="article:author" content="circleGiven"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-02-03 14:05:57"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="circleGiven"><link rel="icon" href="/images/favicon.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="Dev diary"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/favicon.png" alt="Dev diary"><span class="menu__item__link--brand__label">Dev diary</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">Javascript | 표현식과 연산자</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-02-03T05:05:57.000Z" itemprop="datePublished">2018-02-03 14:05:57</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/Dev/">Dev</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/Dev/Javascript/">Javascript</a></div></div><div class="article__contents"><img src="/images/javascript.png"/><p><strong>표현식(expression)</strong>은 자바스크립트 인터프리터가 값으로 평가하는 자바스크립트 구문이다.<br>변수 이름 또한 간단한 표현식으로, 변수에 할당된 임의의 값으로 평가된다.<br>이 표현식들을 이용해 복잡한 표현식을 만들 수 있다.</p>
<p>바로 <strong>연산자(operator)</strong>를 사용하는 것이다.<br>연산자는 피연산자의 값들을 결합해 새로운 값을 만들어낸다.</p>
<h1 id="기본-표현식-primary-expression"><a href="#기본-표현식-primary-expression" class="headerlink" title="기본 표현식 primary expression"></a>기본 표현식 primary expression</h1><p>기본 표현식은 다른 표현식을 포함하지 않은 독립적 표현식이다.<br>자바스크립트에서는 상수, 리터럴, 특정 키워드(예약어), 변수 참조를 말한다.</p>
<p>리터럴은 상수 값으로 프로그램에 직접 포함된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.23</span> <span class="comment">//숫자 리터럴</span></span><br><span class="line"><span class="string">"hello"</span> <span class="comment">//문자 리터럴</span></span><br><span class="line">/pattern/ <span class="comment">//정규표현식 리터럴</span></span><br></pre></td></tr></table></figure></p>
<p>예약어 중에는 기본 표현식이 몇개 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="keyword">this</span> <span class="comment">//'현재'객체</span></span><br></pre></td></tr></table></figure></p>
<p>참조하는 형태도 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i <span class="comment">//변수 i</span></span><br><span class="line">sum <span class="comment">//변수 sum</span></span><br><span class="line"><span class="literal">undefined</span> <span class="comment">//undefined는 전역 변수이다.</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="객체와-배열의-초기화-표현식"><a href="#객체와-배열의-초기화-표현식" class="headerlink" title="객체와 배열의 초기화 표현식"></a>객체와 배열의 초기화 표현식</h1><p>객체와 배열의 초기화 표현식(initializer)는 새로 생성된 객체나 배열을 값으로 하는 표현식이다.<br>‘객체 리터럴’과 ‘배열 리터럴’이라 불리는데, 일반 리터럴과는 달리 기본 표현식은 아니다.<br>이 둘은 프로퍼티와 원소의 값을 지정하는 수많은 하위 표현식을 포함할 수 있기 때문이다.</p>
<p>배열 초기화는 대괄호<code>[]</code> 안에서 쉼표<code>,</code>로 구분되는 표현식 리스트다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [] <span class="comment">//빈 배열</span></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>+<span class="number">4</span>] <span class="comment">//세 개의 원소를 가진 배열</span></span><br></pre></td></tr></table></figure></p>
<p>배열 초기화 표현식 안에 또다른 배열 초기화가 가능하다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]];</span><br></pre></td></tr></table></figure></p>
<p>배열 초기화 표현식에 사용되는 원소 표현식은 매번 배열이 초기화 될 떄마다 평가된다.<br>이는 배열 초기화 표현식이 평가될 때마다 원소의 값이 달라질 수 있음을 의미한다.</p>
<p>배열 리터럴에서 쉼표 사이의 값을 생략하면, 원소의 값을 정의하지 않는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,,,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">a; <span class="comment">//[1, empty × 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>배열의 마지막에 쉼표를 놓는다고 마지막이 정의되지 않은 값은 아니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,,,<span class="number">3</span>,];</span><br><span class="line"></span><br><span class="line">a; <span class="comment">//[1, empty × 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>객체 초기화 표현식은 배열 표현식과 유사하다.<br>객체 초기화는 중괄호<code>{}</code> 안에서 <code>프로퍼티</code>이름과 값으로 표현된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;; <span class="comment">//두 개의 프로퍼티</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;; <span class="comment">//프로퍼티 없음</span></span><br></pre></td></tr></table></figure></p>
<p>배열이 중첩되듯 객체도 프로퍼티 중첩이 가능하다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>: &#123;<span class="attr">y</span>:<span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>객체 초기화에 사용한 표현식은 객체가 초기화 될때마다 평가된다.<br>배열과 마찬가지로 프로퍼티값이 달라질 수 있다.<br><br><br><br></p>
<h1 id="함수-정의-표현식"><a href="#함수-정의-표현식" class="headerlink" title="함수 정의 표현식"></a>함수 정의 표현식</h1><p>‘함수리터럴’이라고도 불린다.<br>함수 정의 표현식은 함수를 <strong>정의</strong>하고, 표현식의 값은 새로 정의된 <strong>함수</strong>이다.<br><code>function</code>키워드와 중괄호<code>{}</code>로 이루어진다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="프로퍼티-접근-표현식"><a href="#프로퍼티-접근-표현식" class="headerlink" title="프로퍼티 접근 표현식"></a>프로퍼티 접근 표현식</h1><p>객체의 프로퍼티나 배열의 원소값을 접근 할때 사용한다.<br>자바스크립트에서는 두가지 방법을 제공한다.<br><code>.</code>과 <code>[]</code>이다.</p>
<p><code>.</code>은 <strong>프로퍼티</strong>를 찾는다.<br><code>.</code>의 앞은 객체를 의미하고, <code>.</code>의 뒤는 찾고자하는 프로퍼티를 의미한다.<br>찾고자 하는 프로퍼티가 예약어나, 공백, 숫자가 아닌 경우에는 사용이 <strong>불가능</strong>하다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a.x; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="string">""</span>: <span class="number">1</span>&#125;;</span><br><span class="line">b.<span class="string">""</span>; <span class="comment">//Uncaught SyntaxError: Unexpected string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = &#123;<span class="number">1</span>:<span class="number">2</span>&#125;;</span><br><span class="line">c<span class="number">.1</span>; <span class="comment">//Uncaught SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><code>[]</code>은 <strong>프로퍼티</strong>와 <strong>인덱스</strong>를 찾는다.<br><code>[]</code>의 앞은 객체를 의미하고, <code>[]</code>안은 찾고자 하는 프로퍼티나 인덱스를 의미한다.<br>프로퍼티이름이 숫자가 아닐때는 반드시 <code>&quot;&quot;</code>문자열로 감싸야 된다.<br>찾고자 하는 프로퍼티가 예약어나, 공백, 숫자가 아닌 경우에만 사용이 <strong>가능</strong>하다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line">a[y]; <span class="comment">//Uncaught ReferenceError: y is not defined</span></span><br><span class="line">a[<span class="string">"y"</span>]; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">b[<span class="number">2</span>]; <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = &#123;<span class="number">1</span>:<span class="number">2</span>&#125;;</span><br><span class="line">c[<span class="number">1</span>]; <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>그런데 두 방식모두 앞의 객체가 <code>null</code>이나 <code>undefined</code>의 경우 <strong>TypeError</strong>가 발생한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">c.x; <span class="comment">//Uncaught ReferenceError: c is not defined</span></span><br><span class="line">c[<span class="number">1</span>]; <span class="comment">//Uncaught ReferenceError: c is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>뒤의 인덱스나 프로퍼티가 <code>null</code>이나 <code>undefined</code>의 경우는 에러가 발생하지 않는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">a.z; <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="호출-표현식"><a href="#호출-표현식" class="headerlink" title="호출 표현식"></a>호출 표현식</h1><p>호출 표현식은 함수나 메서드를 호출하는 문법이고, 호출될 함수를 가르키는 함수 표현식으로 시작한다.<br>호출될 함수 뒤에 괄호<code>()</code>안에는 쉼표<code>,</code>를 이용해 호출 인자 목록을 전달할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">0</span>); <span class="comment">//f함수 호출, 인자는 0</span></span><br><span class="line"><span class="built_in">Math</span>.max(x,y,z); <span class="comment">//Math.max함수 호출, 인자는 x,y,z</span></span><br><span class="line">a.sort(); <span class="comment">//a.sort함수 호출, 인자는 없음</span></span><br></pre></td></tr></table></figure></p>
<p>호출 표현식이 평가될 때,<br>함수 표현식이 먼저 평가되고, 호출 인자 표현식이 순서대로 평가된다.</p>
<p>함수표현식의 값이 호출할 수 있는 객체가 아닌경우, TypeError가 발생한다.<br><br><br><br></p>
<h1 id="객체-생성-표현식"><a href="#객체-생성-표현식" class="headerlink" title="객체 생성 표현식"></a>객체 생성 표현식</h1><p>객체 생성 표현식은 새 객체를 생성하고, <strong>생성자</strong>라고 부르는 함수를 호출해 객체에 속한 프로퍼티들을 초기화한다.<br>객체 생성 표현식은 <code>new</code>라는 키워드가 앞에 붙는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure></p>
<p>객체의 생성자 함수를 전달인자 없이 호출할 때, 다음과 같이 괄호를 생략할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>;</span><br></pre></td></tr></table></figure></p>
<p>객체 생성 표현식이 평가될 때, 자바스크립트 인터프리터는 먼저 새로운 빈 객체를 생성한다.<br>이때 생성된 객체는 객체 초기자 <code>{}</code>에 의해 생성되는 객체와 동일하다.</p>
<p>생성 후, 다음으로 주어진 인자들과 함께 생성자를 호출한다.<br>이때 방금 생성된 새 객체를 <code>this</code>키워드의 값으로 설정하여 전달한다.<br>생성자 함수는 이 <code>this</code>를 이용해 새로 생성된 객체의 프로퍼티들을 초기화 한다.</p>
<p>일반적으로 생성자로 사용된 함수는 값을 반환하지 않는다.<br>객체 생성 표현식의 값은 새롭게 생성되고 초기화된 객체이다.</p>
<p>생성자가 특정 객체값을 반환할 경우, 이 값이 객체 생성 표현식의 값이 되고 생성자를 통해 새로 생성된 객체는 버려진다.<br><br><br><br></p>
<h1 id="연산자-개요"><a href="#연산자-개요" class="headerlink" title="연산자 개요"></a>연산자 개요</h1><p>대부분의 연산자는 <code>+</code>나 <code>=</code>같은 부호로 표현되지만, 일부는 <code>delete</code>나 <code>instanceof</code>와 같이 키워드로 표현한다.<br>연산자들은 <strong>우선순위</strong>가 있다.<br>우선순위가 높은 연산자가 먼저 수행된다.</p>
<table>
<thead>
<tr>
<th>연산자</th>
<th>수행되는 연산</th>
<th>결합방향</th>
<th>피연사자 개수</th>
<th>피연산자 타입</th>
<th>반환</th>
</tr>
</thead>
<tbody>
<tr>
<td>++</td>
<td>전치, 후치 증가 (단항 연산)</td>
<td>&lt;-</td>
<td>1</td>
<td>좌변 값</td>
<td>숫자</td>
</tr>
<tr>
<td>–</td>
<td>전치, 후치 감수 (단항 연산)</td>
<td>&lt;-</td>
<td>1</td>
<td>좌변 값</td>
<td>숫자</td>
</tr>
<tr>
<td>-</td>
<td>단항 마이너스 (부정)</td>
<td>&lt;-</td>
<td>1</td>
<td>숫자</td>
<td>숫자</td>
</tr>
<tr>
<td>+</td>
<td>숫자로 변환</td>
<td>&lt;-</td>
<td>1</td>
<td>숫자</td>
<td>숫자</td>
</tr>
<tr>
<td>~</td>
<td>비트단위 NOT (단항연산)</td>
<td>&lt;-</td>
<td>1</td>
<td>정수</td>
<td>정수</td>
</tr>
<tr>
<td>!</td>
<td>논리 NOT (단항 연산)</td>
<td>&lt;-</td>
<td>1</td>
<td>불리언</td>
<td>불리언</td>
</tr>
<tr>
<td>delete</td>
<td>프로퍼티 제거</td>
<td>&lt;-</td>
<td>1</td>
<td>좌변 값</td>
<td>불리언</td>
</tr>
<tr>
<td>typeof</td>
<td>피연산자의 타입을 반환</td>
<td>&lt;-</td>
<td>1</td>
<td>타입 무방</td>
<td>문자열</td>
</tr>
<tr>
<td>void</td>
<td>undefined 값을 반환</td>
<td>&lt;-</td>
<td>1</td>
<td>타입 무방</td>
<td>undefined</td>
</tr>
<tr>
<td>* / %</td>
<td>곱셉, 나눗셈, 나머지</td>
<td>-&gt;</td>
<td>2</td>
<td>숫자, 숫자</td>
<td>숫자</td>
</tr>
<tr>
<td>+ -</td>
<td>덧셈, 뺄셈</td>
<td>-&gt;</td>
<td>2</td>
<td>숫자, 숫자</td>
<td>숫자</td>
</tr>
<tr>
<td>+</td>
<td>문자열 이어붙이기</td>
<td>-&gt;</td>
<td>2</td>
<td>문자열, 문자열</td>
<td>문자열</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>왼쪽으로 이동</td>
<td>-&gt;</td>
<td>2</td>
<td>정수, 정수</td>
<td>정수</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>부호비트를 확장하며 오른쪽으로 이동</td>
<td>-&gt;</td>
<td>2</td>
<td>정수, 정수</td>
<td>정수</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>부호비트를 확장없이 오른쪽으로 이동</td>
<td>-&gt;</td>
<td>2</td>
<td>정수, 정수</td>
<td>정수</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;=</td>
<td>숫자를 비교</td>
<td>-&gt;</td>
<td>2</td>
<td>숫자, 숫자</td>
<td>불리언</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;=</td>
<td>문자열을 알파벳 숫서로 비교</td>
<td>-&gt;</td>
<td>2</td>
<td>문자열, 문자열</td>
<td>불리언</td>
</tr>
<tr>
<td>instanceof</td>
<td>객체 타입 확인</td>
<td>-&gt;</td>
<td>2</td>
<td>객체, 생성자</td>
<td>불리언</td>
</tr>
<tr>
<td>in</td>
<td>프로퍼티가 존재하는지 확인</td>
<td>-&gt;</td>
<td>2</td>
<td>문자열, 객체</td>
<td>불리언</td>
</tr>
<tr>
<td>==</td>
<td>동등한지 비교 (형변환 x)</td>
<td>-&gt;</td>
<td>2</td>
<td>타입 무방</td>
<td>불리언</td>
</tr>
<tr>
<td>!=</td>
<td>동등하지 않은지 비교 (형변환 x)</td>
<td>-&gt;</td>
<td>2</td>
<td>타입 무방</td>
<td>불리언</td>
</tr>
<tr>
<td>===</td>
<td>일치하는지 비교 (형변환 o)</td>
<td>-&gt;</td>
<td>2</td>
<td>타입 무방</td>
<td>불리언</td>
</tr>
<tr>
<td>!==</td>
<td>일치하지 않은지 비교 (형변환 o)</td>
<td>-&gt;</td>
<td>2</td>
<td>타입 무방</td>
<td>불리언</td>
</tr>
<tr>
<td>&amp;</td>
<td>비트단위 AND</td>
<td>-&gt;</td>
<td>2</td>
<td>정수</td>
<td>정수</td>
</tr>
<tr>
<td>^</td>
<td>비트단위 XOR</td>
<td>-&gt;</td>
<td>2</td>
<td>정수</td>
<td>정수</td>
</tr>
<tr>
<td>&#124;</td>
<td>비트단위 OR</td>
<td>-&gt;</td>
<td>2</td>
<td>숫자</td>
<td>숫자</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>논리 AND</td>
<td>-&gt;</td>
<td>2</td>
<td>타입 무방, 타입 무방</td>
<td>타입 무방</td>
</tr>
<tr>
<td>&#124;&#124;</td>
<td>논리 OR</td>
<td>-&gt;</td>
<td>2</td>
<td>타입 무방, 타입 무방</td>
<td>타입 무방</td>
</tr>
<tr>
<td>?:</td>
<td>조건부 연산자</td>
<td>&lt;-</td>
<td>3</td>
<td>불리언, 타입 무방, 타입 무방</td>
<td>타입 무방</td>
</tr>
<tr>
<td>=</td>
<td>할당</td>
<td>&lt;-</td>
<td>2</td>
<td>좌변 값, 타입 무방</td>
<td>타입 무방</td>
</tr>
<tr>
<td>+= /= %= *= -= &amp;= ^= &#124;= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</td>
<td>연산을 수반하는 할당</td>
<td>&lt;-</td>
<td>2</td>
<td>좌변 값, 타입 무방</td>
<td>타입 무방</td>
</tr>
<tr>
<td>‘</td>
<td>첫번째 피연산자를 무시하고 두번째 피연산자를 반환</td>
<td>-&gt;</td>
<td>2</td>
<td>타입 무방</td>
<td>타입 무방</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="연산자-부수-효과-side-effect"><a href="#연산자-부수-효과-side-effect" class="headerlink" title="- 연산자 부수 효과 side effect"></a>- 연산자 부수 효과 side effect</h2><p>일부 연산자는 부수효과를 갖는다.<br>할당연산자는 해당 변수의 값이 바뀐다.<br>단항연산자 <code>++</code>나 <code>--</code> 같은경우도 실행되면 기존값을 변경한다.<br><br><br><br></p>
<h1 id="산술-표현식"><a href="#산술-표현식" class="headerlink" title="산술 표현식"></a>산술 표현식</h1><p>기본 산술 연산자는 피연산자를 평가하고 <strong>값을 숫자로 변환</strong>한다.<br>그 다음에 산술 연산자 연산을 수행한다.<br>수로 변환이 불가능한 피연산자는 <code>NaN</code>값으로 변환되며, 피연산자 중 하나라도 <code>NaN</code>일 경우 연산결과도 <code>NaN</code>이다.<br><br></p>
<h2 id="덧셈-연산자"><a href="#덧셈-연산자" class="headerlink" title="- 덧셈 연산자 (+)"></a>- 덧셈 연산자 (+)</h2><p><code>+</code> 연산자가 이항 연산자로 사용될 때는 피연산자 숫자 값을 더하거나 문자열을 이어 붙인다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> <span class="comment">//3</span></span><br><span class="line"><span class="string">"hello"</span> + <span class="string">" "</span> + <span class="string">"there"</span> <span class="comment">//"hello there"</span></span><br><span class="line"><span class="string">"1"</span> + <span class="string">"2"</span> <span class="comment">//"12"</span></span><br></pre></td></tr></table></figure></p>
<p>두 피연산자가 모두 숫자이거나 문자열인 경우 하는일은 명확하다.</p>
<p>하지만 타입이 다른경우 <strong>타입 변환</strong>이 이루어져야 하고,<br>연산은 타입 변환후에 수행된다.</p>
<p><code>+</code>연산자는 타입변환시에 <strong>문자열 이어붙이기</strong>를 먼저 수행한다.<br>만일 피연산자 중 하나가 문자열이거나 문자열로 바꿀 수 있는 객체인경우,<br>다른 피연산자를 <strong>문자열</strong>로 변환한 후 이어붙인다.</p>
<p><strong>덧셈</strong>의 경우, 두 피연산자가 모두 문자열이 아니거나, 문자열로 변환이 안될때 수행한다.</p>
<ul>
<li>피연산자 중 하나가 문자열이거나 문자열로 변환이 가능한경우 <strong>문자열 이어붙이기</strong>를 수행</li>
<li>위에 해당하지 않는경우 두 피연산자가 숫자(또는 NaN)으로 변환 후 <strong>덧셈</strong> 연산 수행</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">"2"</span> <span class="comment">//"12"</span></span><br><span class="line"><span class="string">"1"</span> + <span class="string">"2"</span> <span class="comment">//"12"</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> <span class="comment">//3</span></span><br><span class="line"><span class="number">2</span> + <span class="literal">null</span> <span class="comment">//2</span></span><br><span class="line"><span class="number">2</span> + <span class="literal">undefined</span> <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>
<p>만약에 여러 피연산자와 같이 쓸 경우 <strong>우선 법칙</strong>에 따라 수행된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="string">" blind mice"</span> <span class="comment">// "3 blind mice"</span></span><br><span class="line"><span class="number">1</span> + (<span class="number">2</span> + <span class="string">" blind mice"</span>) <span class="comment">// "12 blind mice"</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="단항-산술-연산자"><a href="#단항-산술-연산자" class="headerlink" title="- 단항 산술 연산자"></a>- 단항 산술 연산자</h2><p>단항 산술 연산자는 하나의 피연산자를 숫자 타입으로 변환하려 시도한다.</p>
<h3 id="gt-단항-덧셈"><a href="#gt-단항-덧셈" class="headerlink" title="&gt; 단항 덧셈 (+)"></a>&gt; 단항 덧셈 (+)</h3><p>피연산자를 숫자(또는 NaN)로 바꾼 후 값을 반환한다.<br>피연산자가 이미 숫자라면 아무일도 하지 않는다.</p>
<h3 id="gt-단항-뺄셈"><a href="#gt-단항-뺄셈" class="headerlink" title="&gt; 단항 뺄셈 (-)"></a>&gt; 단항 뺄셈 (-)</h3><p>피연산자를 숫자로 바꾼 후, 결과 값의 <strong>부호</strong>를 바꾼다.</p>
<h3 id="gt-증가"><a href="#gt-증가" class="headerlink" title="&gt; 증가 (++)"></a>&gt; 증가 (++)</h3><p>피연산자에 대해 증가연산 을 한다.<br>이때 피연산자는 <strong>반드시 좌변 값(변수, 배열 원소, 객체 프로퍼티)</strong>이어야 한다.<br>아닐경우 <code>++</code>연산자는 이를 숫자 타입으로 변환하고, <code>1</code>을 더한 다음, 원래 변수나 원소, 프로퍼티에 대입한다.</p>
<p>또한 연산자가 위치에따라 결과 값이 다르다.<br>피연산자 앞에 있을 경우 <code>전치증가</code>연산자라고 하며, 먼저 피연산자를 <strong>증가</strong>시킨 다음 증가된 값을 결과로 내놓는다.<br>피연산자 뒤에 있을 경우 <code>후치증가</code>연산자라고 하며, 먼저 결과값을 내놓고, 피연산자를 <strong>증가</strong>시킨다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>, j = ++i; <span class="comment">//2, 2</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>, j = i++; <span class="comment">//2, 1</span></span><br></pre></td></tr></table></figure></p>
<p><code>++</code>는 <code>x=x+1</code>과 항상 같지않다.<br><code>++</code>는 문자열 결합연산을 하지 않고, 항상 피연산자를 숫자로 변환한 후 값을 하나 증가시킨다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"1"</span>;</span><br><span class="line">a++; <span class="comment">//2</span></span><br><span class="line">a+<span class="number">1</span>; <span class="comment">//"11"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="gt-감소-–"><a href="#gt-감소-–" class="headerlink" title="&gt; 감소 (–)"></a>&gt; 감소 (–)</h3><p><code>--</code>연산자도 <code>++</code>연산자와 같다.<br>피연산자 앞에 있을 경우 <code>전치감소</code>연산자라고 하며, 먼저 피연산자를 <strong>감소</strong>시킨 다음 감소된 값을 결과로 내놓는다.<br>피연산자 뒤에 있을 경우 <code>후치감소</code>연산자라고 하며, 먼저 결과값을 내놓고, 피연산자를 <strong>감소</strong>시킨다.<br><br></p>
<h2 id="비트-단위-연산자"><a href="#비트-단위-연산자" class="headerlink" title="- 비트 단위 연산자"></a>- 비트 단위 연산자</h2><p>비트 단위 연산자들은 2지수 를 저수준에서 조작하는데 사용한다.<br>사칙연산과 같은 산술 연산을 수행하지 않지만, 피연산자로 숫자값을 사용하고<br>최종적으로는 숫자 값을 반환한다.</p>
<p>비트연산자 <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>는 피연산자의 개별비트에 대해 불리언대수를 수행한다.<br>이때 피연산자의 개별 비트는 불리언 값으로 취급된다. (1=true, 0=false)</p>
<p>나머지 비트연산자 <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>는 비트를 이동할 때 사용된다.</p>
<p>비트 단위 연산자의 피연산자로는 <strong>정수</strong>가 온다.<br>정수는 32비트 정수 표현법을 따른다. (64비트 부동소수점 표현법이 아니다.)</p>
<p>비트 단위 연산자는 피연산자를 숫자로 바꾸고, 32번째 이후 비트를 잘라내어 <strong>강제로 피연산자 값을 32비트</strong>로 만든다.</p>
<p>이동 연산자의 우측 피연산자는 0과 31사이의 값이어야 한다.<br>이동 연산자는 피연산자를 32비트 정수로 변환한 후 여섯번째 이상의 비트를 버림으로써 이 숫자가 적절한 범위에 들도록 한다.</p>
<p><code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>는 비트 단위 연산자의 피연산자로 사용 될때 모두 <code>0</code>으로 바뀐다.</p>
<h3 id="gt-비트-단위-AND-amp"><a href="#gt-비트-단위-AND-amp" class="headerlink" title="&gt; 비트 단위 AND (&amp;)"></a>&gt; 비트 단위 AND (&amp;)</h3><p><code>&amp;</code>연산자는 두 정수 피연산자의 개별 비트끼리 불리언 AND 연산을 수행한다.<br>동일 위치의 비트가 두 피연산자에서 모두 설정되어 있어야만 결과 값을 해당 비트도 설정된다.</p>
<h3 id="gt-비트-단위-OR"><a href="#gt-비트-단위-OR" class="headerlink" title="&gt; 비트 단위 OR (|)"></a>&gt; 비트 단위 OR (|)</h3><p><code>|</code>연산자는 두 정수 피연산자의 개별 비트끼리 불리언 OR 연산을 수행한다.<br>적어도 하나 이상의 피연산자에서 특정위치의 비트가 설정되어 있으면 결과 값이 해당 위치 비트가 설정된다.</p>
<h3 id="gt-비트-단위-XOR"><a href="#gt-비트-단위-XOR" class="headerlink" title="&gt; 비트 단위 XOR (^)"></a>&gt; 비트 단위 XOR (^)</h3><p><code>^</code>연산자는 두 정수 피연산자의 개별 비트끼리 배타적 불리언 OR(XOR)연산을 수행한다.<br>배타적 OR이란 두 연산자 중 하나가 true지만 둘 다 true는 아닐 때 결과가 true가 된다.<br>두 피연산자 중 하나에만 특정 위치의 비트가 설정되어 있으면 결과 값이 해당 위치 비트로 설정된다.</p>
<h3 id="gt-비트-단위-NOR"><a href="#gt-비트-단위-NOR" class="headerlink" title="&gt; 비트 단위 NOR (~)"></a>&gt; 비트 단위 NOR (~)</h3><p><code>~</code>연산자는 단항 연산자로 하나의 정수 피연산자 앞에 위치한다.<br><strong>모든 비트를 반전시킨다.</strong><br>어떤 값에 <code>~</code>연산자를 적용하면 그 값의 <strong>부호</strong>를 바꾸고 <code>1</code>을 빼는 것과 같다.</p>
<h3 id="gt-왼쪽으로-이동-lt-lt"><a href="#gt-왼쪽으로-이동-lt-lt" class="headerlink" title="&gt; 왼쪽으로 이동 (&lt;&lt;)"></a>&gt; 왼쪽으로 이동 (&lt;&lt;)</h3><p><code>&lt;&lt;</code>연산자는 첫 번째 피연산자의 모든 비트를 두 번째 피연산자에서 지정한 자릿수 만큼 <strong>왼쪽으로 이동</strong>시킨다.<br><strong>두 번째 피연산자는 반드시 0과 31사이의 정수여야 한다.</strong></p>
<p>a &lt;&lt; 1 의 경우,<br>첫 번째 비트 -&gt; 두 번째 비트<br>두 번째 비트 -&gt; 세 번째 비트<br>이런 방법으로 이동 시킨다.</p>
<p>비트 이동시 첫 번째 비트는 새로 0으로 만들어 진다.<br>기존의 32번째 비트는 이동됨으로써 사라지게 된다.<br>왼쪽으로 한 번 이동하게 되면 기존에 <code>2</code>를 곱한것과 같다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> &lt;&lt; <span class="number">2</span> <span class="comment">//28 (7*2*2)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="gt-오른쪽으로-이동-gt-gt"><a href="#gt-오른쪽으로-이동-gt-gt" class="headerlink" title="&gt; 오른쪽으로 이동 (&gt;&gt;)"></a>&gt; 오른쪽으로 이동 (&gt;&gt;)</h3><p><code>&gt;&gt;</code>연산자는 첫 번째 피연산자의 모든 비트를 두 번째 피연산자에서 지정한 자릿수 만큼 <strong>오른쪽으로 이동</strong>시킨다.<br><strong>두 번째 피연산자는 반드시 0과 31사이의 정수여야 한다.</strong></p>
<p>오른쪽으로 이동시 맨 오른쪽 비트가 사라진다.</p>
<p>가장 왼쪽에 채워질 비트는 최초 피연산자의 부호가된다.<br>첫 번째 피연산자가 <strong>양수</strong>면, 이동시 최상위 비트는 <code>0</code>이 되고,<br>첫 번째 피연산자가 <strong>음수</strong>면, 이동시 최상위 비트는 <code>1</code>이 된다.</p>
<p>오른쪽으로 한 번 이동하게 되면 기존에 <code>2</code>를 나눈것과 같다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>&gt;&gt;<span class="number">1</span> <span class="comment">//3 (7/2)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="gt-0으로-채우면서-오른쪽으로-이동-gt-gt-gt"><a href="#gt-0으로-채우면서-오른쪽으로-이동-gt-gt-gt" class="headerlink" title="&gt; 0으로 채우면서 오른쪽으로 이동 (&gt;&gt;&gt;)"></a>&gt; 0으로 채우면서 오른쪽으로 이동 (&gt;&gt;&gt;)</h3><p><code>&gt;&gt;&gt;</code>연산자는 <code>&gt;&gt;</code>연산자와 한 가지를 제외하고 똑같다.<br>차이점은, 왼쪽 자리에 새로 들어오는 비트가 부호관계 없이 항상 <code>0</code>이라는 것이다.<br><br><br><br></p>
<h1 id="관계형-표현식"><a href="#관계형-표현식" class="headerlink" title="관계형 표현식"></a>관계형 표현식</h1><p>관계형 연산자는 두 피연산자의 값의 관계를 검사하여,<br>성립하면 <strong>true</strong>를, 실패하면 <strong>false</strong>를 반환한다.<br>이들은 항상 불리언 값으로 평가되고, 이 값은 프로그램 실행의 흐름을 제어하기 위한 <strong>if문, while문, for 루프문</strong>에서 주로 사용된다.<br><br></p>
<h2 id="일치와-동치연산자"><a href="#일치와-동치연산자" class="headerlink" title="- 일치와 동치연산자"></a>- 일치와 동치연산자</h2><p><code>==</code>와 <code>===</code>연산자 모두 주어진 두 값이 같은지를 확인하는 데 쓰이지만 같음을 정의하는 기준이 서로 다르다.<br>두 연산자 모두 피연산자의 타입을 가리지 않고, 주어진 피연산자들이 같으면 <strong>true</strong>를, 다르면 <strong>false</strong>를 반환한다.</p>
<h3 id="gt-일치연산자-불일치-연산자"><a href="#gt-일치연산자-불일치-연산자" class="headerlink" title="&gt; 일치연산자 (===) | 불일치 연산자 (!==)"></a>&gt; 일치연산자 (===) | 불일치 연산자 (!==)</h3><p><code>===</code>연산자는 <strong>일치 연산자</strong>로, 두 피연산자가 <strong>일치(identical)</strong>하는지 확인한다.<br><strong>타입 변환을 허용하지 않는다.</strong><br>일치 여부 판단시 다음의 규칙을 따른다.</p>
<ul>
<li>두 값의 타입이 서로 다르면 두 값은 일치하지 않는다.</li>
<li>두 값이 모두 null이거나 undefined이면, 두 값은 일치한다.</li>
<li>두 값이 모두 true이거나 false이면, 두 값은 일치한다.</li>
<li>적어도 하나의 값이 <strong>NaN</strong>이라면, 두 값은 일치하지 않는다.</li>
<li>두 값이 모두 숫자이고 같은 값을 갖는다면, 두 값은 일치한다.<br>(0, -0일때도 일치한다.)</li>
<li>두 값이 모두 문자열이고 같은 위치에 같은 16비트 값을 가지고 있다면, 두 값은 일치한다.<br>만약 문자열의 길이나 내용이 다른경우, 두 값은 일치하지 않는다.<br>(육안상 같은 문자열이어도 <strong>16비트 값의 순서</strong>가 다를경우 일치하지 않는다. 이런경우 <strong>String.localeCompare()</strong>를 참조)</li>
<li>두 값이 모두 같은 객체나 배열 또는 함수를 참조하고 있으면, 두 값은 일치한다.<br>(두 값이 같은 프로퍼티를 가져도 다른 객체를 참조할 경우, 두 값은 일치하지 않는다.</li>
</ul>
<h3 id="gt-동치연산자-부등치-연산자"><a href="#gt-동치연산자-부등치-연산자" class="headerlink" title="&gt; 동치연산자 (==) | 부등치 연산자 (!=)"></a>&gt; 동치연산자 (==) | 부등치 연산자 (!=)</h3><p><code>==</code>연산자는 <strong>동치 연산자</strong>로, 두 피연산자가 <strong>동등(equal)</strong>한지 확인하고, 필요에 따라 <strong>타입 변환을 하용한다.</strong><br>동치 여부 판단시 다음의 규칙을 따른다.</p>
<ul>
<li>두 값의 타입이 같은 경우, 두 값이 일치하는지 테스트한다.<br>만약 두 값이 일치할 경우 두 값은 동치이다.</li>
<li>두 값의 타입이 다르다면 다음의 규칙을 따라 타입변환을 시도한다.<ul>
<li>두 값중 하나가 null이고 다른하나가 undefined라면 두 값은 동등하다.</li>
<li>한 값이 숫자이고 다른 하낙 문자열이라면, 문자열을 숫자로 변환 후 비교한다.</li>
<li>두 값중 하나가 true라면 이를 1로 변환한 후 다시 비교한다.<br>false라면 이를 0으로 변환한 후 비교한다.</li>
<li>한 값이 객체이고, 다른 하나는 숫자 또는 문자열이면, 객체를 원시타입의 값으로 변환한 후 다시 비교한다.<br>해당 객체의 <strong>toString()</strong>이나 <strong>valueOf()</strong>메서드를 사용한다.</li>
<li>이 이외에 기타 값의 조합은 동치가 아니다.</li>
</ul>
</li>
</ul>
<p>다음의 표현식을 살펴보자.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1"</span> == <span class="literal">true</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>이 표현식은 <strong>true</strong>가 된다.<br>먼저 불리언 값인 <code>true</code>가 숫자 <code>1</code>로 변환된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1"</span> == <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>이어서 문자열 <code>&quot;1&quot;</code>이 숫자 <code>1</code>로 변환된다,<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>이러한 과정때문에 표현식의 결과로 true가 반환된다.<br><br></p>
<h2 id="비교-연산자"><a href="#비교-연산자" class="headerlink" title="- 비교 연산자"></a>- 비교 연산자</h2><p>비교 연산자는 두 피연산자의 값의 <strong>상대적인 순서</strong>를 판단하는데 쓰인다.<br>피연산자 타입에 제한이 없으나, 오직 숫자와 문자열만 비교 할 수 있다.<br>숫자와 문자열이 아닌경우, 먼저 변환되는데 다음과 같은 규칙을 따른다.</p>
<ul>
<li>피연사자 중 어느 하나가 객체라면, 원시타입의 값으로 변환이 시도된다.<br><strong>valueOf()</strong>와 <strong>toString()</strong>이 사용된다,</li>
<li>객체가 타입변환 후 피연산자가 모두 문자열이라면, <strong>16비트 유니코드 값</strong>의 순서로 비교한다.</li>
<li>객체가 타입변환 후 피연산자 중 하나가 문자열이 아니라면, 피연산자 모두 숫자로 변환하고 비교한다.<br>(infinity는 infinity가 아닌 어떤 수보다 크고, -infinity는 -infinity가 아닌 어떤 수보다 작다.)</li>
<li>변환 후, 피연산자 중 하나가 <strong>NaN</strong>이라면 항상 false를 반환한다.</li>
</ul>
<p>비교 연산자 들은 <code>+</code>연산자와 마찬가지로 문자열이 올 경우와, 숫자가 올 경우 다르게 동작한다.</p>
<p>비교연산자의 피연산자 중 하나가 <strong>NaN</strong>인 경우 <strong>false</strong>이다</p>
<h3 id="gt-더-작다-lt"><a href="#gt-더-작다-lt" class="headerlink" title="&gt; 더 작다 (&lt;)"></a>&gt; 더 작다 (&lt;)</h3><p><code>&lt;</code>연산자는 첫 번째 피연산자가 두 번째 피연산자보다 작으면 <strong>true</strong>로,<br>그렇지 않으면 <strong>false</strong>로 평가된다.</p>
<h3 id="gt-더-크다-gt"><a href="#gt-더-크다-gt" class="headerlink" title="&gt; 더 크다 (&gt;)"></a>&gt; 더 크다 (&gt;)</h3><p><code>&gt;</code>연산자는 첫 번째 피연산자가 두 번째 피연산자보다 크면 <strong>true</strong>로,<br>그렇지 않으면 <strong>false</strong>로 평가된다.</p>
<h3 id="gt-작거나-같다-lt"><a href="#gt-작거나-같다-lt" class="headerlink" title="&gt; 작거나 같다 (&lt;=)"></a>&gt; 작거나 같다 (&lt;=)</h3><p><code>&lt;=</code>연산자는 첫 번째 피연산자가 두 번째 피연산자보다 작거나 같으면 <strong>true</strong>로,<br>그렇지 않으면 <strong>false</strong>로 평가된다.<br>같음을 비교할 경우 <strong>동치연산자</strong>로 작동하지 않는다.<br>단순히 <strong>크지 않다</strong>로 정의된다.</p>
<h3 id="gt-크거나-같다-gt"><a href="#gt-크거나-같다-gt" class="headerlink" title="&gt; 크거나 같다 (&gt;=)"></a>&gt; 크거나 같다 (&gt;=)</h3><p><code>&gt;=</code>연산자는 첫 번째 피연산자가 두 번째 피연산자보다 크거나 같으면 <strong>true</strong>로,<br>그렇지 않으면 <strong>false</strong>로 평가된다,<br>같음을 비교할 경우 <strong>동치연산자</strong>로 작동하지 않는다.<br>단순히 <strong>작지 않다</strong>로 정의된다.<br><br></p>
<h2 id="in-연산자"><a href="#in-연산자" class="headerlink" title="- in 연산자"></a>- in 연산자</h2><p><code>in</code>연산자 는 좌변의 피연산자로 <strong>문자열(또는 문자열로 변환 가능한 것)</strong>을 받는다.<br>우변의 피연산자로는 <strong>객체</strong>나 <strong>배열</strong>을 받는다.<br>좌변의 값이 우변 객체의 프로퍼티 이름에 해당할 경우, 연사결과는 true이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 우변 피연산자로 올 "객체"</span></span><br><span class="line"><span class="keyword">var</span> point = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> point; <span class="comment">//true</span></span><br><span class="line"><span class="string">"z"</span> <span class="keyword">in</span> point; <span class="comment">//false</span></span><br><span class="line"><span class="string">"toString"</span> <span class="keyword">in</span> point <span class="comment">//true (상속된 프로퍼티)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 우변 피연산자로 올 "배열"</span></span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="string">"0"</span> <span class="keyword">in</span> data; <span class="comment">//true</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> data; <span class="comment">//true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> data; <span class="comment">//false (3번째 원소가 없다)</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="instanceof-연산자"><a href="#instanceof-연산자" class="headerlink" title="- instanceof 연산자"></a>- instanceof 연산자</h2><p><code>instanceof</code>연산자는 좌변의 피연산자로 <strong>객체</strong>를,<br>우변의 피연산자로 <strong>객체 클래스의 이름</strong>을 받는다.<br>좌변의 오는 객체가 우변 객체 클래스의 인스턴스일 경우, 연산결과는 true이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof로 평가할 객체</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Date</span>; <span class="comment">//true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true (모든 객체는 Object를 상속받는다.)</span></span><br><span class="line">a insatnceof <span class="built_in">Number</span>; <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// inastanceof로 평가할 배열</span></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true (모든 배열 Object를 상속받는다.)</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Number</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p><code>instanceof</code>연산자로 객체가 클래스의 인스턴스인지 판단할 때,<br>해당 객체의 <strong>상위 클래스</strong>도 판단한다.<br>(그래서 위 예제에서 Object가 true로 나온 원인)</p>
<p>만약 <code>instanceof</code>연산자의 좌변 피연산자가 객체가 아닌경우 false를 반환하고,<br>우변 피연산자가 함수(클래스)가 아닌경우 <strong>TypeError</strong>가 발생한다.</p>
<p><code>instanceof</code>연산자는 다음과 같이 동작한다.<br><strong>o instanceof f</strong>란 표현식을 평가하자.<br>먼저, f.prototype을 평가한 후, o의 프로토타입 체인에 f.prototype이 나타나는지 검색한다.<br>만일 o의 프로토타입 체인에 f.prototype값이 발견되면 o는 f의 인스턴스(또는 f의 하위클래스의 인스턴스)가 된다.<br><br><br><br></p>
<h1 id="논리-표현식"><a href="#논리-표현식" class="headerlink" title="논리 표현식"></a>논리 표현식</h1><p>논리 연산자는 불리언 대수를 수행한다.<br>종종 비교연산자와 같이 사용된다.<br><br></p>
<h2 id="논리-AND-amp-amp"><a href="#논리-AND-amp-amp" class="headerlink" title="- 논리 AND (&amp;&amp;)"></a>- 논리 AND (&amp;&amp;)</h2><p><code>&amp;&amp;</code>연산자가 단순히 <strong>불리언 피연산자</strong>에 대해 쓰일 경우 두 피연산자의 값에 대한 불리언 AND를 수행한다.<br>첫 번째 피연산자와 두 번째 피연산자 모두 true일 경우에만 연산결과로 true가 반환된다.<br>적어도 하나 이상 피연산자가 false라면 연산결과는 false이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">a &amp;&amp; b; <span class="comment">//true</span></span><br><span class="line">c &amp;&amp; b; <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>주로 비교연산자(관계 표현식)과 함께 사용된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x == <span class="number">0</span> &amp;&amp; y ==<span class="number">0</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>비교연산자(관계 표현식)는 항상 true나 false로 평가되기 때문에, <code>&amp;&amp;</code>를 사용하면 항상 true나 false를 반환한다.</p>
<p>그러나, 불리언 피연산자가 아닌 <strong>true나 false로 평가되는 값</strong>들이 오는경우 반환 결과는 다르다.</p>
<p>자바스크립트에는 true로 평가될 수 있는 <strong>truthy</strong>와 false로 평가되는 <strong>falsy</strong>가 있다.<br>falsy는 <strong>false, null, undefined, 0, -0, NaN, ‘’(빈 문자열)</strong>이다.<br>만일 이러한 값으로 <code>&amp;&amp;</code>연산을 하는 경우 그 값 자체를 반환한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// truthy한 값</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">a &amp;&amp; a.x; <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>a &amp;&amp; a.x; 를 보면 a는 객체이고 a.x는 1이다.<br>두 값모두 <strong>truthy</strong>한 값이다. 결과 값은 값 자체를 반환한다.</p>
<p>그런데 왜 하필 a를 반환하지 않고 a.x를 반환하는가?</p>
<p>이는 논리 AND연산의 수행 과정때문이다.<br>논리 AND연산은 모든 값이 truthy인지 평가한다.</p>
<blockquote>
<p>a &amp;&amp; a.x 수행과정</p>
<ul>
<li>a를 평가한다.<br>a는 객체이므로 <strong>truthy</strong>한 값이다.</li>
<li>truthy한 값이므로 다음 피연산자인를 평가한다.<br>a.x는 숫자이므로 <strong>truthy</strong>한 값이다.<br>-<strong>truthy</strong>한 값인 a.x를 반환하고 수행을 종료한다.</li>
</ul>
</blockquote>
<p>하지만, <strong>평가 도중 값이 falsy하다면 그 falsy한 값 자체를 반환하고 뒤의 값은 평가하지 않는다.</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// truthy한 값</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// falsy한 값</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">a &amp;&amp; a.x; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">a &amp;&amp; b; <span class="comment">//null</span></span><br><span class="line">b &amp;&amp; a; <span class="comment">//null</span></span><br></pre></td></tr></table></figure></p>
<p>a &amp;&amp; b 와 b &amp;&amp; a를 비교해보자.<br>둘의 결과는 같지만 수행과정이 다르다.</p>
<blockquote>
<p>a &amp;&amp; b 수행과정</p>
<ul>
<li>a를 평가한다.<br>a는 객체이므로 <strong>truthy</strong>한 값이다.</li>
<li>truthy한 값이므로 다음 피연산자를 평가한다.<br>b는 null로 <strong>falsy</strong>한 값이다.</li>
<li><strong>falsy</strong>한 값인 b를 반환하고 수행을 종료한다.</li>
</ul>
<p>b &amp;&amp; a 수행과정</p>
<ul>
<li>b를 평가한다.<br>b는 null이기 때문에 <strong>falsy</strong>한 값이다.</li>
<li>falsy한 값이 왔으므로 다음 피연산자인를 평가하지 않는다.</li>
<li><strong>falsy</strong>한 값인 b를 반환하고 수행을 종료한다.</li>
</ul>
</blockquote>
<p>사실 불리언 비교도 마찬가지로 위 truthy와 falsy의 수행 과정을 따른것이다.<br>(true는 truthy, false는 falsy 값이다.)</p>
<p><code>&amp;&amp;</code>연산자의 이러한 특성을 <strong>단축 평가</strong>라고 부른다.<br>그래서 이러한 코드들이 나올 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a==b) stop(); <span class="comment">//a==b라면 stop()을 수행한다.</span></span><br><span class="line">(a==b) &amp;&amp; stop(); <span class="comment">//작동은 위와 같다</span></span><br></pre></td></tr></table></figure></p>
<p>평가 과정에서 해당 식을 수행하기 때문에 (a==b) &amp;&amp; stop()같은 코드가 나올 수 있다.</p>
<blockquote>
<p><strong>논리 AND(&amp;&amp;)</strong>연산은 다음과 같은 수행과정을 갖는다.</p>
<ul>
<li>첫 번째 피연산자를 평가한다.</li>
<li>첫 번째 피연산자가 <strong>truthy</strong>라면 다음 피연산자를 평가한다.</li>
<li>다음 피연산자가 <strong>truthy</strong> 라면 해당 피연산자를 반환한다.</li>
<li>첫 번째 피연산자가 <strong>falsy</strong>라면 다음 피연산자를 평가하지 않고, 첫 번째 피연산자를 반환한다.</li>
</ul>
</blockquote>
<p><br></p>
<h2 id="논리-OR"><a href="#논리-OR" class="headerlink" title="- 논리 OR (||)"></a>- 논리 OR (||)</h2><p><code>||</code>연산자는 두 피연산자에 불리언 OR를 수행한다.<br>두 피연산자 중 하나가 <strong>truthy</strong>라면 그 값을 반환한다.</p>
<p><code>&amp;&amp;</code>연산자는 모든 값이 <strong>truthy</strong>인지 확인을 하지만,<br><code>||</code>연산자는 하나의 값만 <strong>truthy</strong>이면 되기 때문에 다른 수행 과정을 가진다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// truthy한 값</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// falsy한 값</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">a || a.x; <span class="comment">//&#123;x:1&#125;</span></span><br><span class="line">b || a; <span class="comment">//&#123;x:1&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>a || a.x 수행과정</p>
<ul>
<li>먼저 a를 평가한다.<br>a는 객체이므로 <strong>truthy</strong>한 값이다.</li>
<li>truthy한 값이므로 다음 피연산자를 평가하지 않는다.</li>
<li><strong>truthy</strong>한 값인 a를 반환하고 수행을 종료한다.</li>
</ul>
<p>b || a 수행과정</p>
<ul>
<li>먼저 b를 평가한다.<br>b는 null이므로 <strong>falsy</strong>한 값이다.</li>
<li>falsy한 값이므로 다음 피연산자를 평가한다.<br>a는 객체이므로 <strong>truthy</strong>한 값이다.</li>
<li><strong>truthy</strong>한 값인 a를 반환하고 수행을 종료한다.</li>
</ul>
</blockquote>
<p><br></p>
<blockquote>
<p><strong>논리 OR(||)</strong>연산은 다음과 같은 수행과정을 갖는다.</p>
<ul>
<li>첫 번째 피연산자를 평가한다.</li>
<li>첫 번째 피연산자가 <strong>falsy</strong>한 값이라면 다음 피연산자를 평가한다.</li>
<li>만약, 첫 번째 피연산자가 <strong>truthy</strong>한 값이라면 다음 피연산자를 평가하지 않고, 첫 번째 피연산자를 반환한다.</li>
</ul>
</blockquote>
<p><br></p>
<h2 id="논리-NOT"><a href="#논리-NOT" class="headerlink" title="- 논리 NOT (!)"></a>- 논리 NOT (!)</h2><p><code>!</code>연산자는 단항 연산자이다.<br>이 연산자는 단일 피연산자 앞에 놓이다.<br>연산자의 목적은 피연산자의 불리언 값을 <strong>반전</strong>, 즉 반대로 바꾸는 것이다.</p>
<p><code>&amp;&amp;</code>와 <code>||</code>와는 다르게 <code>!</code>연산자는 피연산자를 반전시키기 전에 불리언 값으로 변환한다.<br>그래서 항상 true나 false값을 반환한다. (truthy나 falsy값을 반환하지 않는다!)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line">!a; <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;; <span class="comment">//truthy한 값</span></span><br><span class="line">!a; <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="할당-표현식"><a href="#할당-표현식" class="headerlink" title="할당 표현식"></a>할당 표현식</h1><p><code>=</code>연산자를 사용해 변수나 프로퍼티에 값을 할당한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>; <span class="comment">//변수 i에 0 할당</span></span><br><span class="line">o.x = <span class="number">1</span>; <span class="comment">//객체 o의 프로퍼티 x에 1 할당</span></span><br></pre></td></tr></table></figure></p>
<p>좌변 피연산자로는 변수, 객체 프로퍼티, 배열의 원소가 올 수 있다.<br>우변 피연산자는 어떤 값이라도 올 수 있다.</p>
<p><code>=</code>연산자로 할당하면 오른쪽 값의 참조가 이루어져 할당된다.</p>
<p>할당연산자의 결합방향은 오른쪽에서 왼쪽으로, 여러개의 할당연산이 이루어질 경우 해당 규칙을 따른다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = j = k = <span class="number">1</span>; <span class="comment">//모두 1이다</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="연산을-동반하는-할당"><a href="#연산을-동반하는-할당" class="headerlink" title="- 연산을 동반하는 할당"></a>- 연산을 동반하는 할당</h2><p><code>=</code>연산자 말고도 연산을 동반하는 <strong>할당 연산자</strong>도 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">total = total + <span class="number">1</span>; <span class="comment">//위와 동일하다</span></span><br></pre></td></tr></table></figure></p>
<p>할당 연산자들은 다음과 같이 있다.</p>
<table>
<thead>
<tr>
<th>연산자</th>
<th>표현식</th>
<th>동일한 표현식</th>
</tr>
</thead>
<tbody>
<tr>
<td>+=</td>
<td>a += b</td>
<td>a = a + b</td>
</tr>
<tr>
<td>-=</td>
<td>a -= b</td>
<td>a = a - b</td>
</tr>
<tr>
<td>*=</td>
<td>a *= b</td>
<td>a = a * b</td>
</tr>
<tr>
<td>/=</td>
<td>a /= b</td>
<td>a = a / b</td>
</tr>
<tr>
<td>%=</td>
<td>a %= b</td>
<td>a = a % b</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>a &lt;&lt;= b</td>
<td>a = a &lt;&lt; b</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>a &gt;&gt;= b</td>
<td>a = a &gt;&gt; b</td>
</tr>
<tr>
<td>&gt;&gt;&gt;=</td>
<td>a &gt;&gt;&gt;= b</td>
<td>a = a &gt;&gt;&gt; b</td>
</tr>
<tr>
<td>&amp;=</td>
<td>a &amp;= b</td>
<td>a = a &amp; b</td>
</tr>
<tr>
<td>&#124;=</td>
<td>a &#124;= b</td>
<td>a = a &#124; b</td>
</tr>
<tr>
<td>^=</td>
<td>a ^= b</td>
<td>a = a ^ b</td>
</tr>
</tbody>
</table>
<p>동일한 표현식이라고 하나 작동원리는 다르다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a += b;</span><br><span class="line">a = a + b;</span><br></pre></td></tr></table></figure></p>
<p>a += b에서 a는 <strong>한 번만 평가</strong>된다.<br>a = a + b에서 a는 <strong>두 번 평가</strong>된다.<br>그래서 항상 같은 것은 아니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[i++] *= <span class="number">2</span>;</span><br><span class="line">data[i++] = data[i++] * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>아래의 경우 두번 평가되기 때문에 i++연산이 두 번 일어난다.<br><br><br><br></p>
<h1 id="평가-표현식"><a href="#평가-표현식" class="headerlink" title="평가 표현식"></a>평가 표현식</h1><p>다른 인터프리터 언어와 마찬가지로 자바스크립트도 문자열을 자바스크립트 코드로 해석하고,<br>이를 평가한 결과를 값으로 출력하는 기능이 있다.<br>이와 같은 일은 전역함수 <strong>eval()</strong>이 수행한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"3+2"</span>); <span class="comment">//5</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="eval"><a href="#eval" class="headerlink" title="- eval()"></a>- eval()</h2><p>eval()함수는 <strong>단 하나의 전달인자</strong>를 갖는다.<br>전달인자로 문자열이 아닌 값을 전달하면, 넘긴 값을 그대로 반환한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="literal">true</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>문자열을 전달하면 문자열을 자바스크립트 코드로 해석하려 한다.<br>이때 해석하지 못하면 <strong>SyntaxError</strong>가 발생한다.<br>해석한다면 코드를 평가후 마지막 표현식의 값을 반환한다.<br>이때 값이 없다면 <strong>undefined</strong>를 반환한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"1+1"</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>해석하는 도중 예외가 발생하면 eval()을 호출한 부분에서 전파된다.</p>
<p>eval()함수의 핵심은 eval()이 <strong>호출되는 시점의 코드의 변수 환경을 사용</strong>한다는 점이다.<br>지역코드와 똑같은 방식으로 변수의 값을 찾고, 새로운 변수나 함수를 정의한다는 것이다.<br>함수 안에서 지역변수 x를 선언하고 eval(‘x’)를 호출하면 지역변수 x의 값을 얻는다.<br>eval(‘x=1’)처럼 지역변수의 값을 바꿀 수도 있다.<br><br></p>
<h2 id="전역-eval"><a href="#전역-eval" class="headerlink" title="- 전역 eval()"></a>- 전역 eval()</h2><p>eval()은 지역변수 값을 바꾸기 때문에 자바스크립트 최적화에 문제가 된다.<br>그래서 인터프리터는 eval()을 호출하는 함수에 대해서 많은 최적하를 하지 않는다.</p>
<p>만일 eval()함수가 eval이 아닌 다른이름으로 호출할 경우, 인자로 전달된 문자열은 <strong>최상위 전역변수</strong>로 평가된다.<br>(ES3에서는 <strong>EvalError</strong>가 발생한다.)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geval = <span class="built_in">eval</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">"global"</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">"global"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">"local"</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">"x+='changed'"</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="comment">//지역변수 값이 변경</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="string">"local"</span>;</span><br><span class="line">  geval(<span class="string">"y+='changed'"</span>);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125; <span class="comment">//전역변수 값이 변경</span></span><br><span class="line"></span><br><span class="line">f(); <span class="comment">//"localchanged"</span></span><br><span class="line">x; <span class="comment">//"global"</span></span><br><span class="line"></span><br><span class="line">g(); <span class="comment">//"local"</span></span><br><span class="line">y; <span class="comment">//"globalchanged"</span></span><br></pre></td></tr></table></figure></p>
<p>IE9이전에서의 eval()은 다른이름으로 호출해도 전역으로 eval()이 수행되지 않았다.<br>(<strong>EvalError</strong>도 발생하지 않는다.)<br>단순히 지역범위에서만 실행되었다.</p>
<p>대신에 execScript()라는 함수가 정의되어 있으며 eval()과 같은 동작을 한다.<br>(단, 항상 null을 반환한다.)<br><br></p>
<h2 id="엄격모드의-eval"><a href="#엄격모드의-eval" class="headerlink" title="- 엄격모드의 eval()"></a>- 엄격모드의 eval()</h2><p>ES5의 엄격모드는 eval을 <strong>식별자</strong>로 사용되는 것을 제한한다.<br>eval()이 엄격모드에서 호출되거나, 인자 문자열이 “use strict” 지시자로 시작한다면,<br>eval()은 private 변수 환경을 갖는 지역 eval로 실행된다.</p>
<p>즉, 엄격모드에서 평가된 코드는 기존에 선언된 지역 변수 값을 읽거나 설정할 수 있지만,<br>해당 지역 유효범위 내에 새 변수나 함수를 정의할 수는 없다.</p>
<p>또한, 엄격모드에서 eval을 거의 예약어로 만들어서 eval()을 연산자 처럼 만든다.<br>새 값으로 덮어쓸 수 없고, 함수 이름과 변수 이름, 함수 매개변수 이름 뿐만아니라 catch 블록의 인자로 eval이란 이름을 사용할 수 없다.<br><br><br><br></p>
<h1 id="기타-연산자"><a href="#기타-연산자" class="headerlink" title="기타 연산자"></a>기타 연산자</h1><p><br></p>
<h2 id="조건부-연산자"><a href="#조건부-연산자" class="headerlink" title="- 조건부 연산자 ( ? : )"></a>- 조건부 연산자 ( ? : )</h2><p>조건부 연산자는 자바스크립트의 유일한 3항 연산자(피연산자 3개)이다.<br>연산자는 <code>?:</code>로 표시되지만 실제 코드에서는 피연산자 위치에 따라 다르다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &gt; <span class="number">0</span> ? x : -x; <span class="comment">//x&gt;0이면 x를 아니면 -x를 반환</span></span><br></pre></td></tr></table></figure></p>
<p>첫 번재 피연산자는 <code>?</code>앞에 위치하고,<br>두 번째 피연산자는 <code>?</code>와 <code>:</code> 사이에 위치하고,<br>세 번째 피연산자는 <code>:</code>뒤에 위치한다.</p>
<p>첫 번째 피연산자는 값이 <strong>true(truthy)</strong>로 평가되면,<br>두 번째 피연산자가 평가되고 그 값이 반환된다.<br>만약 첫 번째 피연산자 값이 <strong>false(falsy)</strong>로 평가되면,<br>세 번째 피연산자를 평가하고 그 값을 반환한다.</p>
<p>보통 <code>if</code>문과 비슷한 결과를 얻는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">greeting = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//조건부 연산자 사용</span></span><br><span class="line">greeting += username ? username : <span class="string">"there"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if문 사용</span></span><br><span class="line"><span class="keyword">if</span>(username) &#123;</span><br><span class="line">  greeting += username;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  greeting += <span class="string">"there"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="typeof-연산자"><a href="#typeof-연산자" class="headerlink" title="- typeof 연산자"></a>- typeof 연산자</h2><p><code>typeof</code>연산자는 단일 피연산자 앞에 오는 단항 연산자로,<br>피연산자는 어떤 타입이라도 올 수 있다.<br>이 연산자는 피연산자의 <strong>데이터 타입</strong>을 가르키는 문자열이다.<br>연산자를 사용함으로서 얻을수 있는 결과는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>x</th>
<th>typeof x</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>“undefined”</td>
</tr>
<tr>
<td>null</td>
<td>“object”</td>
</tr>
<tr>
<td>true, false</td>
<td>“boolean”</td>
</tr>
<tr>
<td>숫자, NaN</td>
<td>“number”</td>
</tr>
<tr>
<td>문자열</td>
<td>“string”</td>
</tr>
<tr>
<td>함수</td>
<td>“function”</td>
</tr>
<tr>
<td>함수가 아닌 객체</td>
<td>“object”</td>
</tr>
<tr>
<td>호스트 객체</td>
<td>“undefined”나 “boolean”, “number”, “string”을 제외한 구현부 정의 문자열</td>
</tr>
</tbody>
</table>
<p><code>typeof</code>연산자는 다음과 같이 사용한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">//"number"</span></span><br><span class="line"><span class="keyword">typeof</span>(a); <span class="comment">//"number"</span></span><br></pre></td></tr></table></figure></p>
<p><code>typeof</code>연산자는 함수를 제외한 모든 객체와 배열을 object로 평가하기 때문에, 객체를 다른 원시타입과 구분하는 용도로만 사용할 수 있다.<br>객체의 클래스를 구분하기 위해서는 instanceof나 class속성, constructor프로퍼티와 같은 다른 수단을 사용해야 한다.</p>
<p>자바스크립트에서 함수는 객체의 일종이지만, <code>typeof</code>연산자는 함수들이 자신들의 반환값을 가지고 있다는 점에서 일반 객체와는 다르다고 판단한다.<br>함수와 호출가능한 객체 사이에 차이점이 있다.<br>모든 함수는 호출이 가능하다.<br>하지만 함수가 아닌데도 함수처럼 호출 가능한 객체가 있다.</p>
<p>ES3에서는 <code>typeof</code>연산자는 모든 호출 가능한 일반객체는 “function”을 반환해야 한다고 명시했다.<br>ES5에서는 <code>typeof</code>연산자는 모든 호출 가능한 객체는 일반객체든 호스트 객체든 관계없이 “function”을 반환해야 한다고 확장했다.</p>
<p>하지만 IE9 전에는 함수처럼 호출 가능한 객체라도 <code>typeof</code>연산자를 사용하면 “object”를 반환했다.<br><br></p>
<h2 id="delete-연산자"><a href="#delete-연산자" class="headerlink" title="- delete 연산자"></a>- delete 연산자</h2><p><code>delete</code>는 단항 연산자이며, 피연산자는 객체 프로퍼티, 배열 원소, 변수가 오며 해당 피연산자를 <strong>삭제</strong>한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span> o.x; <span class="comment">//true</span></span><br><span class="line">o; <span class="comment">//&#123;y:2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">2</span>]; <span class="comment">//true</span></span><br><span class="line">a; <span class="comment">//[1,2, empty]</span></span><br></pre></td></tr></table></figure></p>
<p>삭제된 프로퍼티나 원소는 단순히 undefined 값으로 설정된 것이 아니다.<br>어떤 프로퍼티가 삭제되면 해당 프로퍼티는 더 이상 존재하지 않는다.<br>단, 배열의 원소가 삭제되면 해당 원소자리에 **’빈 자리(empty)’가 생긴다.<br>그리고 배열의 길이 또한 달라지지 않는다. (결과적으로 희소배열이 된다.)</p>
<p><code>delete</code>연산자의 피연산자는 좌변 값이다.<br>피연산자가 좌변 값이 아닐 경우 아무런 동작을 하지않고 true를 반환한다.<br>피연산자가 좌변 값인 경우 삭제를 시도하며 성공시 true를 반환하고, 실패시 false를 반환한다.</p>
<p>하지만 모든 변수나 프로퍼티를 삭제할 수는 없다.<br>몇몇 내장 코어프로퍼티나, 클라이언트 측 프로퍼티는 삭제할 수 없으며,<br>var을 이용한 사용자 정의 변수들도 삭제할 수 없다.<br>(ES5 엄격모드에서 부적절한 피연산자가 올 경우 SyntaxError가 발생한다.)<br>피연산자가 오직 접근표혁식 형태일 경우에만 정상 작동한다.<br><br></p>
<h2 id="void-연산자"><a href="#void-연산자" class="headerlink" title="- void 연산자"></a>- void 연산자</h2><p><code>void</code>는 단일 피연산자 앞에 쓰이는 단항 연산자로, 피연산자는 어떠한 타입이라도 올 수 있다.<br>이 연산자는 사용빈도가 낮다.<br>피연산자를 무시하고 undefined를 반환하기 때문이다.<br><code>void</code>연산자를 사용하면 피연산자의 값이 버려지기 때문에, 피연산자가 부수 효과를 갖고 있을 때만 의미있다.</p>
<p>가장 일반적인 사용처는 클라이언트 측 javascript:URL이다.<br>이 URL은 사용자가 어떤 자바스크립트 표현식의 부수효과를 평가할 때,<br>평가된 값을 브라우저에 표시하지 않으면서 표현식을 평가할 수 있게 한다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void window.open();"</span>&gt;</span>Open New Window<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>이 HTML코드는 javascript:URL대신에 onclick 이벤트 핸들러 사용이 가능하다.<br>그럴경우 <code>void</code>연산자가 필요없다.<br><br></p>
<h2 id="쉼표-연산자"><a href="#쉼표-연산자" class="headerlink" title="- 쉼표(,) 연산자"></a>- 쉼표(,) 연산자</h2><p>쉼표연산자는 이항 연산자로, 피연산자들은 어떤 타입이라도 올 수 있다.<br>이 연산자는 왼쪽의 전달인자를 평가하고, 오른쪽의 전달인자를 평가한 후, 오른쪽 전달인자의 값을 반환한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span>, j=<span class="number">1</span>, k=<span class="number">2</span>; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span>; j=<span class="number">1</span>; k=<span class="number">2</span>; <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>두 코드는 동일하다.</p>
<p>왼쪽의 표현식 들은 항상 평가되지만 값은 반환되지 않는다. (마지막 값만 반환된다)</p>
<p>보편적으로 <code>for</code>루프에서 많이 쓰인다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, j=<span class="number">10</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i+j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/Javascript/">Javascript</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.jpeg" alt="circleGiven"><a class="article__author__link" title="About circleGiven" rel="author">circleGiven</a><p class="article__author__desc">아직 배울게 너무 많은 '초보 개발자'</p><div class="article__author__socials"><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="circleGiven"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//circleGiven.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-02-06T08:31:41.271Z"><meta itemprop="articleBody" content="표현식(expression)은 자바스크립트 인터프리터가 값으로 평가하는 자바스크립트 구문이다.변수 이름 또한 간단한 표현식으로, 변수에 할당된 임의의 값으로 평가된다.이 표현식들을 이용해 복잡한 표현식을 만들 수 있다.
바로 연산자(operator)를 사용하는 것이다.연산자는 피연산자의 값들을 결합해 새로운 값을 만들어낸다.
기본 표현식..."><meta itemprop="url" content="http://yoursite.com/2018/02/03/javascript-expression-operator/"><meta itemprop="mainEntityOfPage" content="http://yoursite.com/2018/02/03/javascript-expression-operator/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="Dev diary"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://yoursite.com/images/favicon.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://yoursite.com/images/javascript.png"><meta itemprop="url" content="http://yoursite.com/images/javascript.png"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/02/10/javascript-statement/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 문장</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/08/javascript-type/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 타입, 값, 변수</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/09/null-undefined/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript&gt;&gt; null vs undefined</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2018/02/10/javascript-statement/">Javascript | 문장</a></li><li class="recent-posts__item"><a href="/2018/02/03/javascript-expression-operator/">Javascript | 표현식과 연산자</a></li><li class="recent-posts__item"><a href="/2018/01/21/typescript-interface/">Typescript | Interface</a></li><li class="recent-posts__item"><a href="/2018/01/19/class-abstract-interface/">class 와 abstract 그리고 interface 이야기</a></li><li class="recent-posts__item"><a href="/2018/01/18/typescript-variable/">Typescript | 변수 선언에 대해</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">9</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/Speech/">Speech</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/">Dev</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/Javascript/">Javascript</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/Typescript/">Typescript</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/SICP/">SICP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Story/">Story</a><span class="category-list-count">1</span></li></ul></li></ul></div></div></div><p class="copyright"><small>© 2018 circleGiven<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>