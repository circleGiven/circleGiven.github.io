<!DOCTYPE html><html lang="korean"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Javascript | 배열 | Dev diary</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://yoursite.com/2018/03/10/javascript-array/"/>
<meta name="description" content="배열은 정렬된 값의 집합이다.배열 안의 각 값은 원소(element)라고 한다.각 원소는 배열에서 위치를 가리키는 번호를 배정받는데, 이를 인덱스(index)라고 한다. 자바스크립트의 배열은 타입이 고정되어 있지 않다.즉, 같은 배열에 있는 원소…">
<meta name="keywords" content="Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript | 배열">
<meta property="og:url" content="http://yoursite.com/2018/03/10/javascript-array/">
<meta property="og:site_name" content="Dev diary">
<meta property="og:description" content="배열은 정렬된 값의 집합이다.배열 안의 각 값은 원소(element)라고 한다.각 원소는 배열에서 위치를 가리키는 번호를 배정받는데, 이를 인덱스(index)라고 한다. 자바스크립트의 배열은 타입이 고정되어 있지 않다.즉, 같은 배열에 있는 원소…">
<meta property="og:locale" content="korean">
<meta property="og:image" content="http://yoursite.com/images/javascript.png">
<meta property="og:updated_time" content="2018-03-15T14:40:34.707Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript | 배열">
<meta name="twitter:description" content="배열은 정렬된 값의 집합이다.배열 안의 각 값은 원소(element)라고 한다.각 원소는 배열에서 위치를 가리키는 번호를 배정받는데, 이를 인덱스(index)라고 한다. 자바스크립트의 배열은 타입이 고정되어 있지 않다.즉, 같은 배열에 있는 원소…">
<meta name="twitter:image" content="http://yoursite.com/images/javascript.png"><meta property="article:author" content="circleGiven"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-03-10 15:20:26"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="circleGiven"><link rel="icon" href="/images/favicon.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="Dev diary"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/favicon.png" alt="Dev diary"><span class="menu__item__link--brand__label">Dev diary</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">Javascript | 배열</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-03-10T06:20:26.000Z" itemprop="datePublished">2018-03-10 15:20:26</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/Dev/">Dev</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/Dev/Javascript/">Javascript</a></div></div><div class="article__contents"><img src="/images/javascript.png"/><p>배열은 정렬된 값의 <strong>집합</strong>이다.<br>배열 안의 각 값은 <strong>원소(element)</strong>라고 한다.<br>각 원소는 배열에서 위치를 가리키는 번호를 배정받는데, 이를 <strong>인덱스(index)</strong>라고 한다.</p>
<p>자바스크립트의 배열은 타입이 고정되어 있지 않다.<br>즉, 같은 배열에 있는 원소 값의 타입은 서로 다를 수 있다.<br>배열의 원소는 객체가 될 수도 있고, 또 다른 배열이 될 수도 있다.</p>
<p>자바스크립트 배열은 32비트 인덱스를 사용한다.<br>첫 번째 원소의 인덱스는 0이며, 가장 큰 인덱스로는 4294967294(2^32 -2)까지 사용할 수 있다.<br>즉, 배열은 4,294,967,295개의 원소를 가질 수 있다.</p>
<p>자바스크립트 배열은 <strong>동적</strong>이다.<br>배열의 크기가 필요에 따라 커질 수도 있고, 작아질 수도 있다.<br>배열을 생성하거나, 크기가 변경되어 다시 할당을 할 때도 배열 크기를 선언할 필요가 없다.</p>
<p>자바스크립트 배열은 <strong>밀집도가 높지 않다(sparse)</strong>.<br>각 원소의 인덱스가 연속적이지 않아도 되고, 원소들 사이에 빈 자리가 있어도 된다.</p>
<p>자바스크립트 배열에는 <strong>length</strong> 프로퍼티가 존재한다.<br>빈자리가 전혀 없는 배열의 경우 length 프로퍼티의 값은 배열의 크기와 같지만,<br><strong>희소배열(sparse array)</strong>의 경우는 실제 원소의 크기보다 크다.</p>
<p>자바스크립트 배열은 자바스크립트 <strong>객체의 특별한 형태</strong>이고,<br>배열의 인덱스는 프로퍼티 이름인데, 하필 정수인 것이라고 보면 된다.</p>
<p>일반적으로 배열은 객체 프로퍼티를 통해 원소에 접근하는 것보다,<br>정수 첨자를 통해 원소에 접근하는 것이 훨씬 빠르도록 최적화되어 있다.</p>
<p>배열은 <strong>Array.prototype</strong>의 프로퍼티들을 상속받는다.<br>Array.prototype에는 배열을 다루는 여러 메서드가 정의되어 있다.<br>대부분의 메서드는 <strong>제너릭(generic)</strong> 형태이고,<br>이 말은 배열뿐 아니라 <strong>‘유사 배열 객체(array-like object)’</strong>에서도 동일하게 동작한다는 의미이다.<br><br><br><br></p>
<h1 id="배열-만들기"><a href="#배열-만들기" class="headerlink" title="배열 만들기"></a>배열 만들기</h1><p>배열을 만드는 가장 쉬운 방법은 배열 리터럴(<code>[]</code>)을 사용하는 것이다.<br>배열 리터럴은 배열의 원소를 쉼표(<code>,</code>)로 구분해 나열한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = [];                 <span class="comment">// 원소가 없는 배열</span></span><br><span class="line"><span class="keyword">var</span> primes = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>];      <span class="comment">// 숫자 원소가 5개인 배열</span></span><br><span class="line"><span class="keyword">var</span> misc = [<span class="number">1.1</span>, <span class="literal">true</span>, <span class="string">"a"</span>, ];  <span class="comment">// 서로 다른 종류의 세 원소가 존재하며 쉼표로 끝난 배열</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>배열 리터럴의 값으로는 상수뿐 아니라 임의의 표현식도 사용할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> base = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">var</span> table = [base, base+<span class="number">1</span>, base+<span class="number">2</span>, base+<span class="number">3</span>]; <span class="comment">// [1024, 1025, 1026, 1027]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>배열 리터럴은 객체 리터럴 또는 다른 배열 리터럴을 포함할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = [[<span class="number">1</span>, &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;], [<span class="number">2</span>, &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">4</span>&#125;]];</span><br></pre></td></tr></table></figure></p>
<p><br><br>만약 배열 리터럴에서 빠진 부분이 존재할 경우, 해당 부분의 원소 값은 <strong>undefined</strong>가 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = [<span class="number">1</span>, ,<span class="number">3</span>]; <span class="comment">// 세 원소 중 가운데 원소 값은 undefined</span></span><br><span class="line"><span class="keyword">var</span> undefs = [,,];   <span class="comment">// 두 원소 모두 값은 undefined</span></span><br></pre></td></tr></table></figure></p>
<p>배열 리터럴은 마지막 원소 다음에 쉼표를 추가 할 수 있기 때문에 [,,]의 원소 개수는 2개이다.</p>
<p>배열을 만드는 또 다른 방법은 <strong>Array()</strong> 생성자를 사용하는 것이다.<br>이 생성자는 세 가지 방법으로 호출할 수 있다.</p>
<ul>
<li><p><strong>인자 없이 호출하는 방법</strong><br>이 방법은 아무 원소도 없는 빈 배열을 생성하고, 생성된 배열은 배열 리터럴(<code>[]</code>)와 동일하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>배열의 길이를 의미하는 숫자 값을 인자로 주어 호출하는 방법</strong><br>이 방법은 생성자의 인자로 전달받은 숫자 값 만큼 원소를 갖는 배열을 생성한다.<br>이러한 방법은 배열에 저장될 원소의 크기를 알고 있고, 미리 공간을 할당할 때 사용한다.<br>이때 배열에는 어떠한 값도 저장되지 않고, 배열의 인덱스 프로퍼티 값(“0”, “1” 등등) 역시 존재하지 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>); <span class="comment">// length가 10인 배열</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>두 개 이상의 원소, 또는 숫자가 아닌 원소 값 하나를 명시적으로 지정하는 방법</strong><br>이 방법은 생성자의 인자 값들이 배열의 원소가 된다.<br>배열의 생성자를 사용하는 것보다 배열 리터럴을 사용하는 편이 간단하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="string">"test"</span>); <span class="comment">// [5,4,3,2,1,"test"]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br><br></p>
<h1 id="배열의-원소-읽고-쓰기"><a href="#배열의-원소-읽고-쓰기" class="headerlink" title="배열의 원소 읽고 쓰기"></a>배열의 원소 읽고 쓰기</h1><p>배열의 각 원소에 접근할 때에는 <code>[]</code>연산자를 사용한다.<br><code>[]</code>연산자 왼쪽에는 배열 참조 변수가 와야 하며,<br><code>[]</code> 안에는 음이 아닌 정수 값으로 평가되는 임의의 표현식이 위치할 수 있다.<br>이 구문은 배열에서 원소를 읽거나 쓸 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">"world"</span>];  <span class="comment">// 하나의 원소가 있는 배열 a</span></span><br><span class="line"><span class="keyword">var</span> value = a[<span class="number">0</span>];   <span class="comment">// a 배열의 0번째 원소 값을 읽고, 변수 value에 할당</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">3.14</span>;        <span class="comment">// a 배열의 1번째 원소에 값을 할당</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">a[i] = <span class="number">3</span>;           <span class="comment">// a 배열의 2번째 원소에 값을 할당</span></span><br><span class="line">a[i+<span class="number">1</span>] = <span class="string">"hello"</span>;   <span class="comment">// a 배열의 3번쨰 원소에 값을 할당</span></span><br><span class="line">a[a[i]] = a[<span class="number">0</span>];     <span class="comment">// a 배열의 a[i]번째 원소에 a[0]번째 원소 값을 읽고, 할당</span></span><br><span class="line"></span><br><span class="line">a;                  <span class="comment">// ["world", 3.14, 3, "world"]</span></span><br></pre></td></tr></table></figure></p>
<p>배열은 <strong>객체의 특별한 종류</strong>다.<br>배열의 <code>[]</code> 구문은 객체 프로퍼티 접근 때 쓰는 <code>[]</code>와 똑같이 동작한다.<br>자바스크립트는 사용자가 명시한 <strong>숫자 배열 인덱스를 문자열 형태로 바꿔서</strong> 프로퍼티 이름으로 사용한다.<br>예를 들어, 인덱스가 1이라면 문자열 ‘1’로 바꿔서 프로퍼티에 접근하는 것이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;   <span class="comment">// 빈 객체</span></span><br><span class="line">o[<span class="number">1</span>] = <span class="string">"one"</span>; <span class="comment">// 숫자 인덱스 값으로 객체에 값을 할당</span></span><br><span class="line">o;            <span class="comment">// &#123;1: "one"&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>배열이 일반 객체와 다른 점은 속성 이름으로 2^32 보다 작은 양수를 사용할 때,<br>자동으로 length 프로퍼티의 값을 바꾼다는 것이다.<br>앞의 예제 배열 a처럼, 한 개의 원소로 배열을 만들고 1,2,3 인덱스의 값을 할당했다.<br>처음 a의 length는 1이였지만, 결과적으로 4로 바뀌었다.</p>
<p>배열의 인덱스(array index)와 객체 프로퍼티 이름(object property name)을 올바르게 구별할 줄 알아야 좋다.<br>모든 인덱스 값은 프로퍼티 이름이지만, 프로퍼티 이름은 0과 2^32 - 1 사이의 정수여야만 딘덱스가 될 수 있다.<br><strong>모든 배열은 객체이므로, 어떤 이름의 프로퍼티라도 자유롭게 만들 수 있다.</strong><br>하지만 배열에는, <strong>프로퍼티 가운데 인덱스인 것들을 사용하면 length 프로퍼티의 값이 자동으로 갱신</strong>되는 기능을 갖추고 있다.</p>
<p>배열 첨자로 음수나, 정수가 아닌 수들을 사용할 수 있기는 하다.<br>그런데 이 경우에는 <strong>숫자가 문자열로 변환</strong>되고, <strong>변환된 문자열이 배열 객체의 프로퍼티 이름으로 사용</strong>된다.<br>이때 프로퍼티 이름이 양수가 아니기 때문에, 배열의 인덱스가 아닌 <strong>일반 프로퍼티 이름</strong>으로 취급된다.</p>
<p>반대로, 배열 첨자로 양의 정수가 담긴 문자열을 사용하면, 일반 프로퍼티가 아닌 <strong>배열 인덱스</strong>로 쓰인다.<br>소수점 아래가 없는 부동 소수점 값을 쓸 때도 마찬가지다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">-1.23</span>] = <span class="literal">true</span>; <span class="comment">// 속성 값 '-1.23'을 만든다.</span></span><br><span class="line">a[<span class="string">"1000"</span>] = <span class="number">0</span>;   <span class="comment">// 1001번째 원소 값으로 0을 할당</span></span><br><span class="line">a[<span class="number">1.000</span>] = <span class="number">2</span>;    <span class="comment">// 1번째 원소 값으로 2를 할당(a[1]과 같다)</span></span><br></pre></td></tr></table></figure></p>
<p>배열의 인덱스가 특별한 종류의 객체 프로퍼티 이름일 뿐이라는 것은,<br>자바스크립트 배열에서는 “out of bounds” 에러가 발생하지 않는다는 뜻이다.<br>(즉, 배열에 대해 경계 검사를 하지 않는다.)</p>
<p>객체에 존재하지 않는 프로퍼티 이름을 찾는다면, 에러가 발생하지 않고 단순히 undefined 값이 반환된다.<br>이러한 성질은 배열에도 적용된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="literal">true</span>, <span class="literal">false</span>];  <span class="comment">// 두 개의 원소를 가진 배열</span></span><br><span class="line">a[<span class="number">2</span>];               <span class="comment">// undefined : 해당 인덱스에 원소가 없다</span></span><br><span class="line">a[<span class="number">-1</span>];              <span class="comment">// undefined : '-1'이라는 속성 이름에 해당하는 값이 없다</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>모든 배열은 객체다.</strong><br>따라서 배열은 <strong>객체의 프로토타입으로부터 원소들을 상속받을 수 있다.</strong><br>ECMAScript5 에서 배열은 심지어 getter와 setter 메서드를 통해 정의된 원소도 가질 수 있다.<br>그러나 배열 원소를 상속받거나 원소 질의나 생성에 getter/setter를 쓰면 최적화되지 않은 코드를 쓰게 된다고 생각해야 한다.<br>그런 배열의 원소에 접근하는 데 드는 시간은 일반 객체에 프로퍼티 조회시간과 비슷하다.<br><br><br><br></p>
<h1 id="희소배열"><a href="#희소배열" class="headerlink" title="희소배열"></a>희소배열</h1><p>희소배열(sparse array)은 배열에 속한 원소의 위치가 연속적이지 않은 배열을 말한다.<br>보통 배열의 length 프로퍼티는 배열에 속한 원소의 개수를 의미한다.<br>그러나, 희소배열의 경우, length 프로퍼티 값은 배열에 속한 원소의 개수보다 항상 크다.<br><strong>Array()</strong> 생성자를 통해 배열을 만들거나, 단순히 배열의 크기보다 큰 인덱스에 값을 할당하여 만들 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);   <span class="comment">// 원소가 없지만 a.length는 5인 배열</span></span><br><span class="line">a = [?];            <span class="comment">// length가 0인 빈 배열</span></span><br><span class="line">a[<span class="number">1000</span>] = <span class="number">0</span>;        <span class="comment">// 배열의 1000번째에 원소 0을 할당했다.</span></span><br><span class="line">                    <span class="comment">// 원소는 하나 뿐이지만, length는 1001</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>희소배열은 보통 배열보다 일반적으로 느리고, 메모리를 많이 사용할 뿐 아니라,<br>원소를 찾는 데 걸리는 시간이 일반 객체의 속성 값을 찾는 시간만큼 오래걸린다.</p>
<p><strong>배열 리터럴 사용 시 값을 명시하지 않는 방법으로는 희소배열을 만들 수 없다.</strong><br>해당 원소의 값이 undefined가 되기 때문이다.<br>이는 배열에 원소가 아예 존재하지 않는 것이 아니다.<br><code>in</code> 연산자를 사용하면 차이점을 알 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [,,,];          <span class="comment">// 세 개의 원소가 undefined 인 일반 배열</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);   <span class="comment">// 원소가 없는 희소 배열</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a; <span class="comment">//true; a의 0번째 인덱스에 원소가 존재한다(undefined)</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> b; <span class="comment">//false; b의 0번째 인덱스에 원소가 존재하지 않는다.</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>희소배열은 자바스크립트 배열을 이해하는데 매우 중요하다.<br>하지만, 실무에서는 쓰이지 않는다.<br><br><br><br></p>
<h1 id="배열의-길이"><a href="#배열의-길이" class="headerlink" title="배열의 길이"></a>배열의 길이</h1><p>모든 배열에는 <strong>length</strong> 프로퍼티가 있다.<br>이는 자바스크립트 <strong>객체와 배열을 구분하는 중요한 특징</strong>이다.<br>희소배열이 아닌 배열의 경우, length 프로퍼티 값은 배열의 원소 개수를 의미하며,<br>이는 <strong>배열에서 가장 큰 인덱스 값보다 하나 더 큰 값</strong>이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[].length;              <span class="comment">// 원소가 없는 배열이므로 length는 0</span></span><br><span class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>].length;   <span class="comment">// 가장 큰 인덱스는 2이고, length 는 3</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>희소배열의 경우 length 프로퍼티는 항상 원소의 개수보다 큰데,<br>이는 배열의 length가 배열에 속한 모든 원소의 인덱스보다 항상 크다는 의미이다.<br>즉, 희소배열과 관계없이 원소의 인덱스는 배열의 length보다 절대로 크거나 같을 수 없다.<br>이 불변식(invariant)를 유지하기 위해, 배열은 두 가지 독특한 작동을 한다.</p>
<ul>
<li><p>첫 번째,<br>만약 배열에 배열의 현재 크기보다 같거나 큰 인덱스 i를 갖는 원소를 삽입하는 경우,<br>배열의 length 값은 자동으로 i+1로 설정된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.length;   <span class="comment">//3</span></span><br><span class="line">a[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">a.length;   <span class="comment">//6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>두 번째,<br>만약 음이 아니며 기존 length 값보다 작은 정수 n을 length 값으로 할당할 경우,<br>n번째 인덱스보다 크거나 같은 위치에 있는 원소는 배열에서 <strong>삭제</strong>된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.length = <span class="number">3</span>;   <span class="comment">// a[3]과 그보다 큰 인덱스를 가진 원소는 모두 삭제</span></span><br><span class="line">a;              <span class="comment">// [1,2,3]</span></span><br><span class="line">a.length = <span class="number">0</span>;   <span class="comment">// a[0]과 그보다 큰 인덱스를 가진 원소는 모두 삭제</span></span><br><span class="line">a;              <span class="comment">// []</span></span><br><span class="line">a.length = <span class="number">5</span>;   <span class="comment">// length는 5이지만, 배열안에 원소가 없다</span></span><br><span class="line">a;              <span class="comment">// [empty x 5]; length는 5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br>배열의 프로퍼티 값은 기존 값보다 크게 설정할 수 있다.<br>이는 실제로 배열에 새로운 원소를 추가하지는 않고, 단지 배열의 끝부분에 빈 공간을 생성한다.</p>
<p>ECMAScript5에서는 배열의 length 프로퍼티 값을 <strong>Object.defineProperty()</strong> 메서드를 사용해 읽기 전용(read-only)으로 만들 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];    <span class="comment">// 세 개의 원소를 가진 배열, lenth는 3</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">"length"</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;);  <span class="comment">// length 속성 값을 읽기 전용으로 변경</span></span><br><span class="line">a.length = <span class="number">0</span>;   <span class="comment">// length 속성 값을 변경해도 배열의 length는 변하지 않는다</span></span><br></pre></td></tr></table></figure></p>
<p>이와 마찬가지로, 배열의 어떤 원소를 설정 불가능(non-configurable)하게 만든다면, 그 원소는 지울 수 없다.<br>따라서 배열의 length 프로퍼티 값 역시 해당 원소의 인덱스보다 작은 값으로 설정할 수 없다.<br><br><br><br></p>
<h1 id="배열에-원소를-추가하거나-삭제하기"><a href="#배열에-원소를-추가하거나-삭제하기" class="headerlink" title="배열에 원소를 추가하거나 삭제하기"></a>배열에 원소를 추가하거나 삭제하기</h1><p>배열에 원소를 추가하는 방법은 새 인덱스에 값을 할당하면 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];     <span class="comment">// 빈 배열</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">"zero"</span>;  <span class="comment">// 0번째에 값을 할당</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">"one"</span>;   <span class="comment">// 1번째에 값을 할당</span></span><br><span class="line">a;              <span class="comment">// ["zero", "one"]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>직접 할당하는 방법 외에, <strong>push()</strong> 메서드를 사용해 배열의 끝에 원소를 추가하는 방법도 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];           <span class="comment">// 빈 배열</span></span><br><span class="line">a.push(<span class="string">"zero"</span>);       <span class="comment">// 배열의 끝에 원소를 추가</span></span><br><span class="line">a.push(<span class="string">"one"</span>, <span class="string">"two"</span>); <span class="comment">// 배열의 끝에 원소를 두 개 추가</span></span><br><span class="line">a;                    <span class="comment">// ["zero","one","two"]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>push()</strong> 메서드로 배열의 끝에 원소를 추가하는 것은 a[a.length]에 값을 할당하는 것과 같다.<br><strong>unshift()</strong> 메서드를 사용하면 배열의 앞쪽에 원소를 추가할 수 있다.<br>이때 기존 원소들은 인덱스 값이 하나씩 커지면서 옆으로 밀려난다.</p>
<p>객체에서 프로퍼티를 지울 떄와 마찬가지로 <code>delete</code> 연산자로 배열의 원소도 지울 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];    <span class="comment">// 인덱스가 1인 원소를 제거</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> a;         <span class="comment">// false : 인덱스가 1인 원소가 제거되었기 때문</span></span><br><span class="line">a.length;       <span class="comment">// 3 : 원소는 제거되었지만 length는 변하지 않음</span></span><br></pre></td></tr></table></figure></p>
<p>배열의 특정 원소를 지우는 것은, 해당 원소에 undefined 값을 할당하는 것과 의미가 비슷하다.<br>배열의 원소에 <code>delete</code>를 사용하더라도 배열의 length 프로퍼티 값은 바뀌지 않는다.<br>이는 원소가 지워지면서 생기는 공백을 다른 원소가 대신 하지 않는다는 의미이다.<br>즉 배열에서 원소를 delete해버리면 해당 배열은 <strong>희소배열</strong>이 된다.</p>
<p>배열의 length 프로퍼티의 값을 줄이면 <strong>배열의 끝에서부터 원소를 삭제</strong>할 수 있다.<br>배열에는 <strong>pop()</strong> 메서드가 있는데(<strong>push()</strong>와 쌍), 이는 배열의 length를 하나 줄이고, 삭제된 값을 <strong>반환</strong>한다.</p>
<p><strong>배열의 앞에서 삭제</strong>하는 메서드도 있다.<br><strong>shift()</strong>는 (<strong>unshift()</strong>와 쌍) delete와 다르게 모든 원소의 인덱스 값을 하나씩 감소시킨다.</p>
<p><strong>splice()</strong>는 배열의 원소를 추가, 삭제, 대치하는 범용 메서드다.<br>배열의 length 프로퍼티 값을 바꾸고, 배열에 속한 원소의 인덱스를 증가시키거나 감소시킬 수 있다.<br><br><br><br></p>
<h1 id="배열-순회하기"><a href="#배열-순회하기" class="headerlink" title="배열 순회하기"></a>배열 순회하기</h1><p>배열을 순회하는 가장 일반적인 방법은 <code>for</code> 루프를 사용하는 것이다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(o);  <span class="comment">// 객체 o에서 프로퍼티 이름을 배열로 가져온다.</span></span><br><span class="line"><span class="keyword">var</span> values = [];            <span class="comment">// 빈 배열</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];      <span class="comment">// 프로퍼티 이름을 가져옴</span></span><br><span class="line">    values[i] = o[key];     <span class="comment">// 객체 o에서 프로퍼티 의 값을 values 배열에 할당</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>중첩 루프 또는 성능에 민감한 컨텍스트에서 배열을 순회할 때는 매번 배열의 length를 가져오는 것보다,<br>한 번만 가져와서 사용하도록 루프를 최적화 해야한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];      <span class="comment">// 프로퍼티 이름을 가져옴</span></span><br><span class="line">    values[i] = o[key];     <span class="comment">// 객체 o에서 프로퍼티 의 값을 values 배열에 할당</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>위 예제들은 배열에 원소가 가득 차 있고, 각 원소는 적절한 데이터를 가지고 있다고 가정한다.<br>만약 희소배열이나 적절한 데이터가 없는 경우 반드시 테스트를 해야한다.</p>
<p>null이나 undefined 또는 빈 원소를 제외하고 싶다면<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a[i]) <span class="keyword">continue</span>;    <span class="comment">// null이나 undefiend 및 빈 원소일 경우 건너 뜀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> key = keys[i];      <span class="comment">// 프로퍼티 이름을 가져옴</span></span><br><span class="line">    values[i] = o[key];     <span class="comment">// 객체 o에서 프로퍼티 의 값을 values 배열에 할당</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>만약 undefiend 와 빈 원소만 건너뛰고 싶다면<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>) <span class="keyword">continue</span>;  <span class="comment">// 원소 값이 undefined 이거나 빈 원소일 경우 건너 뜀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> key = keys[i];      <span class="comment">// 프로퍼티 이름을 가져옴</span></span><br><span class="line">    values[i] = o[key];     <span class="comment">// 객체 o에서 프로퍼티 의 값을 values 배열에 할당</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>아무 원소도 없는 인덱스는 건너뛰지만, 윈소 값이 undefined인 경우는<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(i <span class="keyword">in</span> a)) <span class="keyword">continue</span>;  <span class="comment">// 빈 원소는 건너 뜀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> key = keys[i];        <span class="comment">// 프로퍼티 이름을 가져옴</span></span><br><span class="line">    values[i] = o[key];       <span class="comment">// 객체 o에서 프로퍼티 의 값을 values 배열에 할당</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>희소배열에 대해 <code>for</code> 루프를 사용하듯, <code>for/in</code> 루프도 사용할 수 있다.<br><code>for/in</code> 루프는 배열의 인덱스를 포함한 프로퍼티 이름들을 한 번에 하나씩 루프 변수에 할당한다.<br>존재하지 않는 인덱스는 루프에 나타나지 않는다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> sparseArray) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = sparseArray[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><code>for/in</code> 루프는 상속받은 프로퍼티 이름까지 나온다.<br>예를 들어, <strong>Array.prototype</strong>에 추가된 메서드의 이름까지 알려준다.<br>따라서 원하지 않는 상속받은 프로퍼티를 제외하는 테스트를 하지 않았다면,<br><code>for/in</code> 루프를 사용하지 말아야 한다.<br><code>for/in</code> 루프를 사용하고 상속받은 프로퍼티를 제외하려면 아래와 같이한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 상속받은 프로퍼티는 제외</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!a.hasOwnProperty(i)) <span class="keyword">continue</span>; <span class="comment">// 상속받은 속성은 건너뜀</span></span><br><span class="line">                                        <span class="comment">// hasOwnProperty()는 상속받은 프로퍼티가 나오지 않음</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//음의 정수로 된 프로퍼티는 제외</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">String</span>(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(i)))) !== i) <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>ECMAScript 에서는 <code>for/in</code> 루프가 객체의 프로퍼티들을 어떤 순서로 순회해야 하는지 정해놓고 있지 않다.<br>일반적으로 대부분 구현체는 배열의 원소를 오름차순으로 순회하지만, 항상 그렇지는 않다.<br>만약 배열이 객체 프로퍼티와 배열의 원소 둘다 가지고 있다면, 프로퍼티 이름은 그 크기 순서가 아니라 생성된 순서대로 반환될 수도 있다.<br>순회하는 순서가 중요하다면, <code>for/in</code> 루프보다 <code>for</code> 루프를 사용해야한다.</p>
<p>ECMAScript5에는 배열을 순회하는 다양한 메서드가 추가되었다.<br>사용자가 정의한 함수에 배열의 원소가 <strong>인덱스 순서대로 하나씩 넘어오도록 하여 배열을 순회</strong>하는 형태다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];     <span class="comment">// 순회에 사용될 배열</span></span><br><span class="line"><span class="keyword">var</span> sumOfSquares = <span class="number">0</span>;       <span class="comment">// 배열의 각 원소를 제곱한 값의 합계</span></span><br><span class="line"></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    sumOfSquares += x*x;    <span class="comment">// 원소 값의 제곱을 sumOfSquares에 누적</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sumOfSquares;               <span class="comment">// 55</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="다차원-배열"><a href="#다차원-배열" class="headerlink" title="다차원 배열"></a>다차원 배열</h1><p>자바스크립트는 실제로 다차원 배열을 지원하지 않는다.<br>그러나, 배열의 병ㄹ을 사용해 다차원 배열을 흉내 낼 수 있다.<br>배열 내의 배열에 있는 원소에 접근하기 위해서는 단순히 <code>[]</code>연산자를 두 번 사용하면 된다.</p>
<p>예를 들어, matrix가 배열의 배열이라 가정하자.<br>matrix[x]의 모든 배열의 원소는 숫자 배열이다.<br>이 숫자 배열의 특정 숫자에 접근하기 위해서는 matrix[x][y]와 같이 쓸 수 있다.</p>
<p>구구단을 작성하기 위해 2차원 배열을 사용하는 방법은 다음과 같다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 다차원 배열</span></span><br><span class="line"><span class="keyword">var</span> table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);  <span class="comment">// 구구단 표의 10개의 행을 만든다</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);   <span class="comment">// 각 행에 10개의 열을 만든다</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열을 초기화</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> row = <span class="number">0</span>; row &lt; table.length; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; table[row].length; col++) &#123;</span><br><span class="line">        table[row][col] = row * col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 * 7 을 계산하기 위한 구구단 표를 사용</span></span><br><span class="line"><span class="keyword">var</span> product = table[<span class="number">5</span>][<span class="number">7</span>];  <span class="comment">// 35</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h1 id="배열-메서드"><a href="#배열-메서드" class="headerlink" title="배열 메서드"></a>배열 메서드</h1><p>ECMAScript3의 <strong>Array.prototype</strong>은 배열을 다루는 데 필요한 여러 종류의 함수를 정의한다.<br>정의된 함수들은 모든 배열에서 <strong>메서드</strong>로 사용할 수 있다.<br><br></p>
<h2 id="join"><a href="#join" class="headerlink" title="- join()"></a>- join()</h2><p><strong>Array.join()</strong> 메서드는 배열의 모든 원소를 <strong>문자열로 변환</strong>하고, 변화한 문자들을 <strong>이어 붙인 결과</strong>를 반환한다.<br>이때 결과로 반환되는 문자열에서 배열의 원소들을 구별하기 위해 <strong>구분자(separator)</strong> 문자열을 사용한다.<br>별도로 구분자 문자열을 지정하지 않으면, <strong>쉼표(<code>,</code>)가 기본값</strong>으로 사용된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];    <span class="comment">// 세 개의 원소를 가진 배열을 생성</span></span><br><span class="line">a.join();           <span class="comment">// "1,2,3"</span></span><br><span class="line">a.join(<span class="string">" "</span>);        <span class="comment">// "1 2 3"</span></span><br><span class="line">a.join(<span class="string">""</span>);         <span class="comment">// "123"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);  <span class="comment">// 길이가 10인 빈 배열을 생성</span></span><br><span class="line">b.join(<span class="string">"-"</span>);            <span class="comment">// "---------": 아홉 개의 하이픈 문자열</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>Array.join()</strong> 메서드는 String.split() 메서드와는 반대로 작동한다.<br><strong>String.split()</strong> 메서드는 문자열을 조각들로 <strong>분리</strong>하고,<br>이 조각들을 <strong>원소로 하는 배열을 생성</strong>한다.<br><br></p>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="- reverse()"></a>- reverse()</h2><p><strong>Array.reverse()</strong> 메서드는 배열의 원소 순서를 반대로 뒤집어 반환한다.<br>이 작업은 배열 안에서 직접 수행된다.<br>즉, 순서가 뒤바뀐 새로운 배열을 생성하는 것이 아니라, <strong>이미 존재하는 배열 안에서 순서를 뒤바꾼다.</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.reverse();</span><br><span class="line">a;        <span class="comment">// [3, 2, 1]</span></span><br><span class="line">a.join(); <span class="comment">// "3,2,1"</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="sort"><a href="#sort" class="headerlink" title="- sort()"></a>- sort()</h2><p><strong>Array.sort()</strong> 메서드는 배열 안의 원소들을 정렬하여 반환한다.<br>sort() 메서드를 별도의 전달인자 없이 호출하면, 배열 안의 원소들을 알파벳순으로 정렬한다.<br>필요한 경우, 비교를 위해 원소들이 잠시 문자열로 변환된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"banana"</span>, <span class="string">"cherry"</span>, <span class="string">"apple"</span>);</span><br><span class="line">a.sort();   <span class="comment">// ["apple","banana","cherry"]</span></span><br><span class="line"><span class="keyword">var</span> s = a.join(<span class="string">", "</span>);</span><br><span class="line">s;          <span class="comment">// "apple, banana, cherry"</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>배열에 undefined 원소가 존재하면, 이 원소는 배열의 <strong>끝부분으로 정렬</strong>된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"banana"</span>,<span class="literal">undefined</span>, <span class="string">"cherry"</span>, <span class="string">"apple"</span>);</span><br><span class="line">a.sort();   <span class="comment">// ["apple","banana","cherry",undefined]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>알파벳순이 아니라 다른 순서로 배열을 정렬하려면, sort() 메서드의 전달인자를 통해 <strong>비교 함수</strong>를 직접 명시해주어야 한다.</p>
<p>비교 함수는 전달인자를 두 개 받아서, 정렬된 배열에서 어떤 것이 먼저 나타나야 하는지 판단한다.<br>만약 <strong>첫 번쨰 인자가 두 번째 보다 먼저 나타나야 한다면, 비교 함수는 0보다 작은 숫자를 반환</strong>해야 한다.<br>(두 번째 인자가 먼저 나타나야 한다면, 비교 함수는 0보다 큰 숫자를 반환해야 한다)<br>만약 두 값이 동등하다면(두 값의 순서를 정하는 것이 무의미하다면) 0을 반환해야 한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">33</span>, <span class="number">4</span>, <span class="number">111</span>, <span class="number">222</span>];</span><br><span class="line">a.sort();   <span class="comment">// 111, 222, 33, 4 : 알파벳 순서이므로</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b; <span class="comment">// 0보다 작거나, 크거나 0을 반환</span></span><br><span class="line">&#125;);             <span class="comment">// 4, 33, 111, 222</span></span><br></pre></td></tr></table></figure></p>
<p>여기서는 <strong>익명 함수 표현식(unnamed function expression)</strong>을 사용하였다.<br>비교 함수는 한 번만 사용되기 때문에 함수에 이름을 부여하지 않아도 되기 때문이다.</p>
<p>배열 원소를 정렬하는 또 다른 예로, 대소문자를 구분하지 않는 알파벳순으로 배열을 정렬할 수 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'ant'</span>, <span class="string">'Bug'</span>, <span class="string">'cat'</span>, <span class="string">'Dog'</span>];</span><br><span class="line">a.sort();   <span class="comment">// ['Bug', 'Dog', 'ang', 'cat'] : 대소문자를 구분한 정렬</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = s.toLowerCase();</span><br><span class="line">    <span class="keyword">var</span> b = t.toLowerCase();</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);         <span class="comment">// ['ant', 'Bug', 'cat', 'Dog'] : 대소문자를 구분하지 않는 정렬</span></span><br></pre></td></tr></table></figure></p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/Javascript/">Javascript</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.jpeg" alt="circleGiven"><a class="article__author__link" title="About circleGiven" rel="author">circleGiven</a><p class="article__author__desc">아직 배울게 너무 많은 '초보 개발자'</p><div class="article__author__socials"><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="circleGiven"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//circleGiven.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-03-15T14:40:34.707Z"><meta itemprop="articleBody" content="배열은 정렬된 값의 집합이다.배열 안의 각 값은 원소(element)라고 한다.각 원소는 배열에서 위치를 가리키는 번호를 배정받는데, 이를 인덱스(index)라고 한다.
자바스크립트의 배열은 타입이 고정되어 있지 않다.즉, 같은 배열에 있는 원소 값의 타입은 서로 다를 수 있다.배열의 원소는 객체가 될 수도 있고, 또 다른 배열이 될 수도..."><meta itemprop="url" content="http://yoursite.com/2018/03/10/javascript-array/"><meta itemprop="mainEntityOfPage" content="http://yoursite.com/2018/03/10/javascript-array/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="Dev diary"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://yoursite.com/images/favicon.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://yoursite.com/images/javascript.png"><meta itemprop="url" content="http://yoursite.com/images/javascript.png"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/09/null-undefined/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript&gt;&gt; null vs undefined</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/02/16/javascript-object/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 객체</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/03/01/javascript-good-parts/"><div class="related-posts__item__background" style="background-image:url('/images/javascript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Javascript | 자바스크립트의 좋은 점과 나쁜점</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2018/03/11/javascript-summary/">javascript-summary</a></li><li class="recent-posts__item"><a href="/2018/03/10/javascript-array/">Javascript | 배열</a></li><li class="recent-posts__item"><a href="/2018/03/06/web-was-difference/">Server | Web server 와 Application server</a></li><li class="recent-posts__item"><a href="/2018/03/01/javascript-good-parts/">Javascript | 자바스크립트의 좋은 점과 나쁜점</a></li><li class="recent-posts__item"><a href="/2018/02/16/javascript-object/">Javascript | 객체</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">9</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/Speech/">Speech</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/">Dev</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/Javascript/">Javascript</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/Server/">Server</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/Typescript/">Typescript</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/SICP/">SICP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Story/">Story</a><span class="category-list-count">1</span></li></ul></li></ul></div></div></div><p class="copyright"><small>© 2018 circleGiven<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>